#!/usr/bin/env bash
# This script was generated by bashly 1.1.10 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
inceptor_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor - CLI to troubleshoot ROSA/OSD clusters\n"
    echo

  else
    printf "inceptor - CLI to troubleshoot ROSA/OSD clusters\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor COMMAND\n"
  printf "  inceptor [COMMAND] --help | -h\n"
  printf "  inceptor --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   troubleshoot operators\n" "check                "
  printf "  %s   Install pre-requistes for executing case summarizer script\n" "setup-case-summarizer"
  printf "  %s   Generate case summary\n" "summarize            "
  printf "  %s   upgrade inceptor binary to the latest released version\n" "upgrade              "
  printf "  %s   Collect must-gather data from ROSA/OSD clusters and attach it to their respective cases.\n" "collect-must-gather  "
  printf "  %s   This command will help you segregate data from a .pcap file.\n" "analyze-pcap         "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
inceptor_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check - troubleshoot operators\n"
    echo

  else
    printf "inceptor check - troubleshoot operators\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check COMMAND\n"
  printf "  inceptor check [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   check image-registry operator\n" "image-registry  "
  printf "  %s   check authentication operator\n" "authentication  "
  printf "  %s   check cloud-credential operator\n" "cloud-credential"
  printf "  %s   check ingress operator\n" "ingress         "
  printf "  %s   check cluster health\n" "cluster-health  "
  printf "  %s   troubleshoot node/machine provisioning related issues\n" "machines        "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
inceptor_check_image_registry_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check image-registry - check image-registry operator\n"
    echo

  else
    printf "inceptor check image-registry - check image-registry operator\n"
    echo

  fi

  printf "Alias: ir\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check image-registry CLUSTERID\n"
  printf "  inceptor check image-registry --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_authentication_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check authentication - check authentication operator\n"
    echo

  else
    printf "inceptor check authentication - check authentication operator\n"
    echo

  fi

  printf "Alias: auth\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check authentication CLUSTERID\n"
  printf "  inceptor check authentication --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_cloud_credential_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check cloud-credential - check cloud-credential operator\n"
    echo

  else
    printf "inceptor check cloud-credential - check cloud-credential operator\n"
    echo

  fi

  printf "Alias: cc\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check cloud-credential CLUSTERID\n"
  printf "  inceptor check cloud-credential --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_ingress_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check ingress - check ingress operator\n"
    echo

  else
    printf "inceptor check ingress - check ingress operator\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor check ingress CLUSTERID\n"
  printf "  inceptor check ingress --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_cluster_health_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check cluster-health - check cluster health\n"
    echo

  else
    printf "inceptor check cluster-health - check cluster health\n"
    echo

  fi

  printf "Alias: ch\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check cluster-health CLUSTERID\n"
  printf "  inceptor check cluster-health --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_machines_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check machines - troubleshoot node/machine provisioning related issues\n"
    echo

  else
    printf "inceptor check machines - troubleshoot node/machine provisioning related issues\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor check machines CLUSTERID\n"
  printf "  inceptor check machines --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_setup_case_summarizer_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor setup-case-summarizer - Install pre-requistes for executing case summarizer script\n"
    echo

  else
    printf "inceptor setup-case-summarizer - Install pre-requistes for executing case summarizer script\n"
    echo

  fi

  printf "Alias: setup-cs\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor setup-case-summarizer\n"
  printf "  inceptor setup-case-summarizer --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
inceptor_summarize_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor summarize - Generate case summary\n"
    echo

  else
    printf "inceptor summarize - Generate case summary\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor summarize CASEID\n"
  printf "  inceptor summarize --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CASEID"
    printf "    Support case ID for which the summary will be generated\n"
    echo

  fi
}

# :command.usage
inceptor_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor upgrade - upgrade inceptor binary to the latest released version\n"
    echo

  else
    printf "inceptor upgrade - upgrade inceptor binary to the latest released version\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor upgrade\n"
  printf "  inceptor upgrade --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
inceptor_collect_must_gather_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor collect-must-gather - Collect must-gather data from ROSA/OSD clusters and attach it to their respective cases.\n"
    echo

  else
    printf "inceptor collect-must-gather - Collect must-gather data from ROSA/OSD clusters and attach it to their respective cases.\n"
    echo

  fi

  printf "Alias: collect-mg\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor collect-must-gather CLUSTERID\n"
  printf "  inceptor collect-must-gather --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_analyze_pcap_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor analyze-pcap - This command will help you segregate data from a .pcap file.\n"
    echo

  else
    printf "inceptor analyze-pcap - This command will help you segregate data from a .pcap file.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor analyze-pcap\n"
  printf "  inceptor analyze-pcap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  inceptor check image-registry cluster-id\n"
    printf "  inceptor check auth cluster-id\n"
    printf "  inceptor setup-case-summarizer\n"
    printf "  inceptor summarize case-id\n"
    printf "  inceptor upgrade\n"
    printf "  inceptor collect-must-gather cluster-id\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions

# :command.function
inceptor_check_image_registry_command() {
  # src/check_image_registry_command.sh
  #!/bin/bash

  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  BLUE="\033[44m"
  RESET="\033[0m"
  cluster_id="${args[clusterid]:-$1}"
  search_string="image%20registry%20operator%20degraded%20in%20OpenShift"
  do_kcs_search="true"
  keyword_counter=0

  echo "Enter your username (ex: rhn-support-<kerberos>):"
  read username

  echo "Enter your password:"
  read -s pass

  echo

  login_via_backplane() {
      echo -e "${YELLOW}Logging into the cluster via backplane...${RESET}"
      ocm backplane login $cluster_id
  }

  # For default browsers when prom links function executed ---
  os_default_browser() {
    case $(uname | tr '[:upper:]' '[:lower:]') in
    linux*)
      OPEN="xdg-open"
      ;;
    darwin*)
      OPEN="open"
      ;;
    esac
  }

  get_basic_info() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo -e "${YELLOW}Listing basic information about the cluster...${RESET}"
      osdctl -S cluster context $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Listing the service logs sent in past 30 days...${RESET}"
      osdctl -S servicelog list $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Checking node status...${RESET}"
      oc get nodes
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Function to check the status of the Image Registry Operator
  check_image_registry_operator_status() {
      echo
      echo -e "${YELLOW}Checking Image Registry Operator Status...${RESET}"
      oc get co image-registry
      echo
      echo -e "The below ${GREEN}'.status.conditions'${RESET} section provides insights into the overall health and operational state of the Operator."
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      oc describe co image-registry | awk '/^\s*Conditions:/, /^\s*Extension:/{if(/^\s*Extension:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  # Checking the deployment and pods for image-registry
  check_operator_resources() {
      echo
      echo -e "${YELLOW}Checking the deployment and pods for image-registry...${RESET}"
      echo -e "${GREEN}DEPLOYMENT:${RESET}"
      oc -n openshift-image-registry get deployments
      echo
      echo
      echo -e "${GREEN}PODS:${RESET}"
      oc -n openshift-image-registry get pod
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  check_image_registry_operator_pod_logs() {
      echo
      echo -e "${YELLOW}Gathering Image Registry Operator Pod Logs...${RESET}"
      operator_pod=$(oc -n openshift-image-registry get pods --no-headers -o custom-columns=":metadata.name" | grep cluster-image-registry-operator)
      red_flags=("error" "degraded" "timeout" "expire" "canceled" "ImagePrunerDegraded" "RequestError" "Unavailable" "backoff" "failed" "x509")

      if [ -n "$operator_pod" ]; then
          echo -e "${GREEN}OPERATOR POD NAME: $operator_pod${RESET}"
          echo
          log_output=$(oc --tail 10 logs -n openshift-image-registry "$operator_pod")
          colored_logs="$log_output"
          for word in "${red_flags[@]}"; do
              colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
          done

          # Print the colored logs
          echo -e "$colored_logs"
      else
          echo "No Image Registry Operator pod found."
      fi
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Checking logs of image-registry pods
  check_image_registry_pod_logs() {
      echo
      echo -e "${YELLOW}Gathering logs from one of the image-registry pods...${RESET}"

      red_flags=("error" "degraded" "timeout" "expire" "canceled" "ImagePrunerDegraded" "RequestError" "Unavailable" "backoff" "failed" "x509")

      echo -e "${GREEN}OPERATOR POD NAME: $operator_pod${RESET}"
      echo
      log_output=$(oc --tail 10 -n openshift-image-registry logs deployment/image-registry)
      colored_logs="$log_output"
      for word in "${red_flags[@]}"; do
          colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
      done

      # Print the colored logs
      echo -e "$colored_logs"
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  check_other_configuration() {
      echo
      echo -e "${YELLOW}Listing events from namespace/openshift-image-registry${RESET}"
      oc get events -n openshift-image-registry
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Checking the config for image-registry${RESET}"
      echo -e "${GREEN}oc get configs.imageregistry.operator.openshift.io cluster -o yaml (.status.conditions)${RESET}"
      echo
      oc get configs.imageregistry.operator.openshift.io cluster -o yaml | awk '/^\s*conditions:/, /^\s*generations:/{if(/^\s*generations:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo

      echo -e "${YELLOW}Fetching storage configuration${RESET}"
      echo -e "${GREEN}oc get configs.imageregistry.operator.openshift.io cluster -o json | jq -r '.spec.storage'${RESET}"
      echo
      oc get configs.imageregistry.operator.openshift.io cluster -o json | jq -r '.spec.storage'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo
      echo -e "${YELLOW}Check imagepruner (.status.conditions)${RESET}"
      echo -e "${GREEN}oc get imagepruner cluster -o yaml (.status.conditions)${RESET}"
      oc get imagepruner cluster -o yaml | awk '/^\s*conditions:/, /^\s*observedGeneration:/{if(/^\s*observedGeneration:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  job_pruning_issues() {
      echo -e "${BLUE}KNOWN ISSUES and SOLUTIONS${RESET}"
      echo -e "${YELLOW}PRUNING JOB FAILURES${RESET}"
      echo
      echo -e "A common cause of the cluster operator to become degraded is through the failure of its periodic pruning jobs."

      echo -e "${GREEN}Check for any jobs which did not complete, they will show up as '0/1' in the completions column${RESET}"
      oc get job -n openshift-image-registry
      echo
      echo -e "If any job did not complete, check the logs for the pod corresponding to the job for more information about the failure using the following command:"
      echo -e "${GREEN}oc logs -n openshift-image-registry -l job-name=$JOBNAME${RESET}"
      echo
      echo -e "If successive pruning jobs have completed, ask the SRE/customer to remove the failed jobs using the following command:"
      echo -e "${GREEN}oc delete job -n openshift-image-registry $JOBNAME${RESET}"
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  print_additional_info() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Additional Information:${RESET}"
      echo -e "To get in touch with OCP engineering for this operator, join ${GREEN}forum-imageregistry${RESET} slack channel and ping ${GREEN}@imageregistry-team${RESET} handle with any queries."
  }

  build_search_string() {
      echo -e "${YELLOW}Building search string${RESET}"
      echo
      operator_degraded_message=$(oc get co image-registry -o json | jq -r '.status.conditions[] | select(.type == "Degraded" and .status == "True") | .message')
      if [ -z "$operator_degraded_message" ]; then
          operator_degraded_message=$(oc get co image-registry -o json | jq -r '.status.conditions[] | select(.type == "Progressing" and .status == "True") | .message')
      fi

      #echo -e "OPERTOR MESSAGE : $operator_degraded_message"

      if [ -z "$operator_degraded_message" ]; then
          do_kcs_search="false"
      else
          # Strings to search for
          search_pattern=("Progressing: Unable to apply resources: unable to sync storage configuration: RequestError: send request failed" "ImagePrunerDegraded: Job has reached the specified backoff limit" "Degraded: The deployment does not have available replicas" "unsupported protocol scheme")

          # Variable to store the found strings
          found_strings=""

          # Loop through each search string
          for search_str in "${search_pattern[@]}"; do
              # Check if the search string is present in the paragraph
              if [[ $operator_degraded_message =~ $search_str ]]; then
                  # If found, append it to the variable
                  found_strings="$found_strings $search_str"
                  keyword_counter=$((keyword_counter + 1))
              fi
          done

          if [ "$keyword_counter" -eq 0 ]; then
              # If keyword_counter is  equal to 0, send the original message as found string
              found_strings="$operator_degraded_message"
          fi

          # Print the result
          #echo "Found strings: $found_strings"

          updated_operator_degraded_message=$(echo "$found_strings" | sed 's/ /%20/g')
          search_string="$search_string%20$updated_operator_degraded_message"
          #echo "NEW SEARCH STRINGS: $search_string"
      fi
  }

  search_kcs() {
      echo
      if [ "$do_kcs_search" == "false" ]; then
          echo -e "${GREEN}Couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources related to image-regitry pods. You can also refer the following KCS for further troubleshooting:${RESET}${RED} https://access.redhat.com/solutions/3804741${RESET}"
      else
          echo -e "${YELLOW}Searching for KCS Solutions...${RESET}"
          api_url="https://api.access.redhat.com/support/search/kcs?fq=documentKind:(%22Solution%22)&q=*$search_string*&rows=3&start=0"

  	      # Make the API call and store the response in a variable
          api_response=$(curl -s -X GET -u "$username:$pass" "$api_url")

          # Check if the API call was successful (HTTP status code 200)
          http_status_code=$(curl -s -o /dev/null -w "%{http_code}" "$api_url")

          if [ "$http_status_code" -eq 200 ]; then
              echo "API call was successful."
              echo "API Response:"
              echo "$api_response" | grep -o 'https://access.redhat.com/solutions/[^ ]*' | sed -e 's/["}].*//'
          else
              echo "API call failed with HTTP status code $http_status_code."
          fi
      fi
  }

  get_prometheus_graph_links() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Running prometheus queries...${RESET}"
      echo -e "${YELLOW}Please navigate to the following links to review metrics related to the image registry operator:${RESET}"
      echo

      echo -e "${GRN}Collecting console url...${NC}"
      console_output_file="TEMP_CONSOLE.txt"

      # For backplane console runs in the same terminal
      if [[ -z ${console_url} ]]; then
          podman machine init &> /dev/null
          sleep 1
          podman machine start &> /dev/null
          podman container rm --all --force -i --depend &> /dev/null

          pkill -9 -f "backplane console"
          sleep 15
          rm $console_output_file &> /dev/null

          touch $console_output_file

      # Capturing Console URL ---
          ocm backplane console >> $console_output_file 2>&1  &

          local skipped=true
          for i in $(seq 1 240); do
          if grep -q -e "http" -e "rror" $console_output_file; then
              console_url=$( cat $console_output_file | awk '/available at/ {print $6}')
              skipped=false
              break
          fi
          sleep 1
          done
      fi

      # Console URL fetched ---
      if echo "$console_url" | grep -q "http"; then
          echo -e "Success: ${GRN}$console_url${NC}\n"

      elif [[ $skipped == true ]]; then
          echo -e "${YEL}TIMEOUT ERROR: Unable to retrieve the Console URL.${NC}"
          echo -e "skipping prometheus..."
          console_url=""
          return 1

      else
          local console_error=$(<$console_output_file)
          echo -e "${YEL}The following error occurs while trying to get console URL:\n${RED}--\n$console_error\n--${NC}"
          echo -e "skipping prometheus..."
          console_url=""
          return 1
      fi

      echo -e "${GREEN}1. MONITORING DASHBOARD for namespace/openshift-image-registry: ${RESET}"
      query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=openshift-image-registry&type=deployment"
      echo
      query_url="$console_url/$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      sleep 1
      echo
      echo -e "${GREEN}2. Query Executed:${RESET} kube_job_status_failed{namespace="openshift-image-registry"}"
      echo -e "This query provides information about the ${GREEN}FAILED${RESET} jobs inside the namespace/openshift-image_registry"
      echo
      query="monitoring/query-browser?query0=kube_job_status_failed%7Bnamespace%3D%22openshift-image-registry%22%7D"
      query_url="$console_url/$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      echo
  }

  main() {
      login_via_backplane
      os_default_browser
      get_basic_info
      check_image_registry_operator_status
      check_operator_resources
      check_image_registry_operator_pod_logs
      check_image_registry_pod_logs
      check_other_configuration
      job_pruning_issues
      build_search_string
      search_kcs
      get_prometheus_graph_links
      print_additional_info
  }

  main
}

# :command.function
inceptor_check_authentication_command() {
  # src/check_authentication_command.sh
  #!/bin/bash

  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  BLUE="\033[44m"
  RESET="\033[0m"
  cluster_id="${args[clusterid]:-$1}"
  search_string="authentication%20operator%20degraded%20in%20OpenShift"
  do_kcs_search="true"
  keyword_counter=0

  echo "Enter your username (ex: rhn-support-<kerberos>):"
  read username

  echo "Enter your password:"
  read -s pass

  # Function to login to the cluster via backplane
  login_via_backplane() {
      echo -e "${YELLOW}Logging into the cluster via backplane...${RESET}"
      ocm backplane login $cluster_id
  }

  # For default browsers when prom links function executed ---
  os_default_browser() {
    case $(uname | tr '[:upper:]' '[:lower:]') in
    linux*)
      OPEN="xdg-open"
      ;;
    darwin*)
      OPEN="open"
      ;;
    esac
  }

  # Function to get basic info about the cluster
  get_basic_info() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo -e "${YELLOW}Listing basic information about the cluster...${RESET}"
      osdctl -S cluster context $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Listing the service logs sent in past 30 days...${RESET}"
      osdctl -S servicelog list $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Checking node status...${RESET}"
      oc get nodes
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Function to check the status of the Authentication Operator
  check_authentication_operator() {
      echo
      echo -e "${YELLOW}Checking Authentication Operator Status...${RESET}"
      oc get co authentication
      echo
      echo -e "The below ${GREEN}'.status.conditions'${RESET} section provides insights into the overall health and operational state of the Operator."
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      oc describe co authentication | awk '/^\s*Conditions:/, /^\s*Extension:/{if(/^\s*Extension:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  # Checking the deployment and pods for image-registry
  check_operator_resources() {
      echo
      echo -e "${YELLOW}Checking the deployment and pods for authentication operator...${RESET}"
      echo -e "${GREEN}DEPLOYMENTS:${RESET}"
      oc -n openshift-authentication-operator get deployments
      oc -n openshift-authentication get deployments
      echo
      echo
      echo -e "${GREEN}PODS:${RESET}"
      oc -n openshift-authentication-operator  get pod
      oc -n openshift-authentication get pod
      echo
  }

  # Function to gather Authentication Operator logs.
  get_authentication_operator_logs() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Gathering Authentication Operator Pod Logs...${RESET}"
      operator_pod=$(oc get pods -n openshift-authentication-operator -o=jsonpath='{.items[0].metadata.name}')

      red_flags=("error" "degraded" "timeout" "expire" "canceled" "OAuthServerRouteEndpointAccessibleController" "OAuthServerServiceEndpointAccessibleController reconciliation failed" "IngressStateController reconciliation failed")

      if [ -n "$operator_pod" ]; then
          echo -e "${GREEN}OPERATOR POD NAME: $operator_pod${RESET}"
          echo
          log_output=$(oc --tail 25 logs -n openshift-authentication-operator "$operator_pod")

          colored_logs="$log_output"
          for word in "${red_flags[@]}"; do
              colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
          done

          # Print the colored logs
          echo -e "$colored_logs"
      else
          echo "No Authentication Operator pod found."
      fi
  }

  # Build keyword search string for searching KCS solutions:
  build_search_string() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo -e "${YELLOW}Building search string${RESET}"
      echo
      operator_degraded_message=$(oc get co authentication -o json | jq -r '.status.conditions[] | select(.type == "Degraded" and .status == "True") | .message')
      if [ -z "$operator_degraded_message" ]; then
          operator_degraded_message=$(oc get co authentication -o json | jq -r '.status.conditions[] | select(.type == "Progressing" and .status == "True") | .message')
      fi

      #echo -e "OPERTOR MESSAGE : $operator_degraded_message"

      if [ -z "$operator_degraded_message" ]; then
          do_kcs_search="false"
      else
          # Strings to search for
          search_pattern=("OAuthServerConfigObservationDegraded: failed to apply IDP" "OAuthServerRouteEndpointAccessibleControllerDegraded" "ProxyConfigControllerDegraded:" "APIServerDeploymentDegraded:" "OAuthServerConfigObservationDegraded: error validating configMap" "IngressStateEndpointsDegraded: No endpoints found for oauth-server" "RouteStatusDegraded: route is not available" "context deadline exceeded" "Client.Timeout exceeded while awaiting headers" "healthz")

          # Variable to store the found strings
          found_strings=""

          # Loop through each search string
          for search_str in "${search_pattern[@]}"; do
              # Check if the search string is present in the paragraph
              if [[ $operator_degraded_message =~ $search_str ]]; then
                  # If found, append it to the variable
                  found_strings="$found_strings $search_str"
                  keyword_counter=$((keyword_counter + 1))
              fi
          done

          #echo "Keyword Counter: $keyword_counter"

          if [ "$keyword_counter" -eq 0 ]; then
              # If keyword_counter is  equal to 0, send the original message as found string
              found_strings="$operator_degraded_message"
          fi

          # Print the result
          echo "Found strings: $found_strings"

          updated_operator_degraded_message=$(echo "$found_strings" | sed 's/ /%20/g')
          search_string="$search_string%20$updated_operator_degraded_message"
          #echo "NEW SEARCH STRINGS: $search_string"
      fi
  }

  # Search KCS solutions dynamically using hydra API:
  search_kcs() {
      echo
      if [ "$do_kcs_search" == "false" ]; then
          echo -e "${GREEN}Couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources related to oauth pods. You can also refer the following KCS for further troubleshooting:${RESET}${RED} https://access.redhat.com/articles/5900841#operator${RESET}"
      else
          echo -e "${YELLOW}Searching for KCS Solutions...${RESET}"
          api_url="https://api.access.redhat.com/support/search/kcs?fq=documentKind:(%22Solution%22)&q=*$search_string*&rows=3&start=0"

  	    # Make the API call and store the response in a variable
          api_response=$(curl -s -X GET -u "$username:$pass" "$api_url")

          # Check if the API call was successful (HTTP status code 200)
          http_status_code=$(curl -s -o /dev/null -w "%{http_code}" "$api_url")

          if [ "$http_status_code" -eq 200 ]; then
              echo "API call was successful."
              echo "API Response:"
              echo "$api_response" | grep -o 'https://access.redhat.com/solutions/[^ ]*' | sed -e 's/["}].*//'
          else
              echo "API call failed with HTTP status code $http_status_code."
          fi
      fi
  }

  # Function to gather OAuth server logs
  get_oauth_server_logs() {
      echo
      echo -e "${YELLOW}Checking OAuth Pod Status...${RESET}"
      echo

      echo -e "${GREEN}oc get pods -n openshift-authentication${RESET}"
      oc get pods -n openshift-authentication
      echo
      echo -e "${YELLOW}Gathering OAuth Server Logs...${RESET}"
      oauth_pod=$(oc get pods -n openshift-authentication -o=jsonpath='{.items[?(@.metadata.labels.app=="oauth-openshift")].metadata.name}')

      if [ -n "$oauth_pod" ]; then
          pod1=$(oc get pod -n openshift-authentication | awk 'NR==2{print $1}')
          echo
          echo -e "${GREEN}Capturing logs from pod/$pod1${RESET}"
          oc --tail 10 logs $pod1 -n openshift-authentication

          pod2=$(oc get pod -n openshift-authentication | awk 'NR==3{print $1}')
          echo
          echo -e "${GREEN}Capturing logs from pod/$pod2${RESET}"
          oc --tail 10 logs $pod2 -n openshift-authentication

          pod3=$(oc get pod -n openshift-authentication | awk 'NR==4{print $1}')
          echo
          echo -e "${GREEN}Capturing logs from pod/$pod3${RESET}"
          oc --tail 10 logs $pod3 -n openshift-authentication
          echo
      else
          echo "No OAuth Server pod found."
      fi
  }

  get_users_and_identities() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      # Check user and identity count
      echo -e "${YELLOW}Checking user and identity count for any discrepency. The user count is always greater than the identity count due to backplane user. If this difference is more than 1, it is considered an a discrepency.${RESET}"
      user_count=$(oc get users | grep -v NAME | wc -l)
      echo -e "${GREEN}USERS COUNT${RESET} = $user_count"

      identity_count=$(oc get identity | grep -v NAME | wc -l)
      echo -e "${GREEN}IDENTITY COUNT${RESET} = $identity_count"

      difference=$(echo "scale=2; $user_count - $identity_count" | bc)

      # Check if the difference is greater than 1
      if (( $(echo "$difference > 1" | bc -l) )); then
          echo -e "${YELLOW}There appears to be a discrepency in the user and identity count. Please review the below listed user and identity to find out the discrepency.${RESET}"
          echo -e "${YELLOW}Listing Users...${RESET}"
          oc get users
          echo
  	#print_horizontal_line "-" 120
          echo -e "${YELLOW}Listing identities...${RESET}"
          oc get identity
          echo
      else
          echo -e "${GREEN}As per the analysis, there is no discrepency in the user/identity count.${RESET}"
      fi
  }

  gather_route_data(){
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo -e "${YELLOW}Gathering data for route...${RESET}"
      echo
      echo -e "${GREEN}oc get route -n openshift-authentication${RESET}"
      oc get route -n openshift-authentication
      echo
  }

  get_prometheus_graph_links() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Running prometheus queries...${RESET}"
      echo -e "${YELLOW}Please navigate to the following links to review metrics related to the authentication operator:${RESET}"
      echo

      echo -e "${GRN}Collecting console url...${NC}"
      console_output_file="TEMP_CONSOLE.txt"

      # For backplane console runs in the same terminal
      if [[ -z ${console_url} ]]; then
          podman machine init &> /dev/null
          sleep 1
          podman machine start &> /dev/null
          podman container rm --all --force -i --depend &> /dev/null

          pkill -9 -f "backplane console"
          sleep 15
          rm $console_output_file &> /dev/null

          touch $console_output_file

      # Capturing Console URL ---
          ocm backplane console >> $console_output_file 2>&1  &

          local skipped=true
          for i in $(seq 1 240); do
          if grep -q -e "http" -e "rror" $console_output_file; then
              console_url=$( cat $console_output_file | awk '/available at/ {print $6}')
              skipped=false
              break
          fi
          sleep 1
          done
      fi

      # Console URL fetched ---
      if echo "$console_url" | grep -q "http"; then
          echo -e "Success: ${GRN}$console_url${NC}\n"

      elif [[ $skipped == true ]]; then
          echo -e "${YEL}TIMEOUT ERROR: Unable to retrieve the Console URL.${NC}"
          echo -e "skipping prometheus..."
          console_url=""
          return 1

      else
          local console_error=$(<$console_output_file)
          echo -e "${YEL}The following error occurs while trying to get console URL:\n${RED}--\n$console_error\n--${NC}"
          echo -e "skipping prometheus..."
          console_url=""
          return 1
      fi

      echo -e "${GREEN}1. MONITORING DASHBOARD for namespace/openshift-authentication: ${RESET}"
      query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=openshift-authentication&type=deployment"
      echo
      query_url="$console_url/$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      sleep 1
      echo

      echo -e "${GREEN}2. MONITORING DASHBOARD for namespace/openshift-authentication-operator: ${RESET}"
      query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=openshift-authentication-operator&type=deployment"
      echo
      query_url="$console_url/$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      sleep 1
      echo

      echo -e "${GREEN}3. Query Executed:${RESET} ${YELLOW}up{service="metrics", namespace="openshift-authentication-operator"}${RESET}"
      echo -e "This query provides information about the ${GREEN}up${RESET} status of service inside the namespace/openshift-authentication-operator"
      query="up%7Bservice%3D%22metrics%22%2C+namespace%3D%22openshift-authentication-operator%22%7D"
      query_url="$console_url/monitoring/query-browser?query0=$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      sleep 1
      echo

      echo -e "${GREEN}4. Query Executed:${RESET} ${YELLOW}sum(rate(kube_pod_container_status_restarts_total{pod=~"authentication-operator.*"}[5m]))${RESET}"
      echo -e "This Prometheus query calculates the sum of the per-second rates of pod restarts for ${GREEN}authentication-operator pod${RESET} over the last 5 minutes. It gives you an indication of how frequently containers within authentication operator pods are restarting,"
      query="sum%28rate%28kube_pod_container_status_restarts_total%7Bpod%3D~\"authentication-operator.*\"%7D%5B5m%5D%29%29"
      query_url="$console_url/monitoring/query-browser?query0=$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      sleep 1
      echo

      echo -e "${GREEN}5. Query Executed:${RESET} ${YELLOW}sum(rate(kube_pod_container_status_restarts_total{pod=~"oauth-openshift.*"}[5m]))${RESET}"
      echo -e "This Prometheus query calculates the sum of the per-second rates of pod restarts for ${GREEN}oauth pods${RESET} over the last 5 minutes. It gives you an indication of how frequently containers within authentication operator pods are restarting,"
      query="sum%28rate%28kube_pod_container_status_restarts_total%7Bpod%3D~\"oauth-openshift.*\"%7D%5B5m%5D%29%29"
      query_url="$console_url/monitoring/query-browser?query0=$query"
      echo -e "$query_url"
      $OPEN "$query_url" &>/dev/null
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo

      echo -e "${RED}To get in touch with OCP engineering for this operator, join #forum-apiserver slack channel and ping @api-auth-apiserver-component-questions handle with queries.${RESET}"
  }

  # Main function
  main() {
      login_via_backplane
      os_default_browser
      get_basic_info
      check_authentication_operator
      check_operator_resources
      get_authentication_operator_logs
      get_oauth_server_logs
      get_users_and_identities
      gather_route_data
      build_search_string
      search_kcs
      get_prometheus_graph_links
  }

  main
}

# :command.function
inceptor_check_cloud_credential_command() {
  # src/check_cloud_credential_command.sh
  #!/usr/bin/env bash

  BDEF='\x1B[1m'
  BRED='\x1B[1;31m'
  RED='\x1B[0;31m'
  BYEL='\x1B[1;33m'
  YEL='\x1B[0;33m'
  BGRN='\x1B[1;32m'
  GRN='\x1B[0;32m'
  NC='\x1B[0m' # RESET
  cluster_id="${args[clusterid]:-$1}"

  # For KCS search string
  declare -g -A search_strings

  # Title, separator, logs format ---
  inc_title() {
    echo -e "${YEL}$*${NC}\n"
  }

  inc_separator() {
      echo -e "\n${GRN}------------------------------------------------------------------------${NC}"
  }

  format_logs() {
    while IFS= read -r line; do
      echo $line | sed -e "s/info/${BDEF}&${NC}/" -e "s/\(error\|timeout\|unavailable\)/${BRED}&${NC}/" -e "s/warning/${BYEL}&${NC}/"
    done <<< "$1"
  }

  # Cluster login via ocm backplane ---
  inc_login() {
    echo -e "\n${YEL}Logging into cluster via backplane...${NC}\n"
    ocm_outuput=$(ocm backplane login $cluster_id)
    whoami_output=$(oc whoami 2>&1)
    if [[ $whoami_output == *"rror"* ]]; then
      echo -e "\n${RED}Couldn't login to cluster ${cluster_id}\nexiting..${NC}"
      exit 1
    else
      echo -e "\n${GRN}Login successful. ${NC}"
    fi
  }

  print_json() {
    OUTPUT_FORMAT="${OUTPUT_FORMAT:-yaml}"

    if [[ $OUTPUT_FORMAT == "yaml" ]]; then
      echo "$*" | jq '.' | sed -E -e 's/\{|\}|\[|\]|\"//g' -e 's/,\s*$//g'
    else
      echo "$*" | jq -C '.'
    fi
  }

  # For default browsers when prom links function executed ---
  os_default_browser() {
    case $(uname | tr '[:upper:]' '[:lower:]') in
    linux*)
      OPEN="xdg-open"
      ;;
    darwin*)
      OPEN="open"
      ;;
    esac
  }

  # Cluster Basic information ---
  get_basic_info() {
    inc_separator
    inc_title "Listing basic information about the cluster..."
    osdctl -S cluster context $cluster_id

    inc_separator
    inc_title "Listing the service logs sent in past 30 days..."
    osdctl -S servicelog list $cluster_id

    inc_separator
    inc_title "Checking node status..."
    oc get nodes
  }

  # Additional Information ------
  print_additional_info() {
    inc_separator
    inc_title "Additional Information :"
    echo -e "To get in touch with OCP engineering for this operator, join ${GRN}$1${NC} slack channel for any inquiries."
  }

    # Prometheus link ---
    # For supported operators
  cco_get_prometheus_graph_links() {
    local prom_namespace
    local promql_rules_param
    local rules_url

    console_output_file="TEMP_CONSOLE.txt"

    inc_separator
    prom_namespace=$1
    inc_title "prometheus metrics related to $prom_namespace"

    # For prom alert rules
    case $prom_namespace in
      openshift-cloud-credential-operator)
      promql_rules_param='cco_credentials_requests_conditions{condition=~"CredentialsDeprovisionFailure|CloudCredentialOperatorDeprovisioningFailed|CloudCredentialOperatorInsufficientCloudCreds|CloudCredentialOperatorProvisioningFailed|CloudCredentialOperatorStaleCredentials|CloudCredentialOperatorTargetNamespaceMissing"}'
      ;;
    esac

    echo -e "${GRN}Collecting console url...${NC}"

    # For backplane console runs in the same terminal
    if [[ -z ${console_url} ]]; then
      podman machine init &> /dev/null
      sleep 1
      podman machine start &> /dev/null
      podman container rm --all --force -i --depend &> /dev/null

      pkill -9 -f "backplane console"
      sleep 15
      rm $console_output_file &> /dev/null

      touch $console_output_file

    # Capturing Console URL ---
      ocm backplane console >> $console_output_file 2>&1  &

      local skipped=true
      for i in $(seq 1 240); do
        if grep -q -e "http" -e "rror" $console_output_file; then
          console_url=$( cat $console_output_file | awk '/available at/ {print $6}')
          skipped=false
          break
        fi
        sleep 1
      done
    fi

    # Console URL fetched ---
    if echo "$console_url" | grep -q "http"; then
      echo -e "Success: ${GRN}$console_url${NC}\n"

    elif [[ $skipped == true ]]; then
      echo -e "${YEL}TIMEOUT ERROR: Unable to retrieve the Console URL.${NC}"
      echo -e "skipping prometheus..."
      console_url=""
      return 1

    else
      local console_error=$(<$console_output_file)
      echo -e "${YEL}The following error occurs while trying to get console URL:\n${RED}--\n$console_error\n--${NC}"
      echo -e "skipping prometheus..."
      console_url=""
      return 1
    fi

    # Dashboard ----
    echo -e "${GRN}1. MONITORING DASHBOARD${NC}"
    dashboard_query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=$prom_namespace&type=deployment"
    dashboard_url="$console_url/$dashboard_query"
    echo -e "$dashboard_url"

    # Failed jobs ----
    echo -e "\n"
    echo -e "${GRN}2. FAILED jobs inside the namespace/$prom_namespace${NC}"
    promql_param='kube_job_status_failed{namespace="USED_NAMESPACE"}'
    promql_param_encoded=$(jq -rn --arg x ${promql_param//USED_NAMESPACE/$prom_namespace} '$x|@uri')
    failed_jobs_query="monitoring/query-browser?query0=$promql_param_encoded"
    failed_jobs_url="$console_url/$failed_jobs_query"
    echo -e "$failed_jobs_url"

    # Prometheus alert rules ---
    # For supported operators
    if [[ -n "$promql_rules_param" ]]; then
        echo -e "\n"
        echo -e "${GRN}3. FIRED ALERT rules for namespace/$prom_namespace${NC}"
        promql_rules_param_encoded=$(jq -rn --arg x ${promql_rules_param} '$x|@uri')
        rules_query="monitoring/query-browser?query0=$promql_rules_param_encoded"
        alert_rules_url="$console_url/$rules_query"
        echo -e "$alert_rules_url"
    fi

    echo -e "\n"
    echo -e "${GRN}Opening the URLs in the browser ..${NC}"
    $OPEN "$dashboard_url" &>/dev/null
    sleep 1
    $OPEN "$failed_jobs_url" &>/dev/null
    sleep 1
    if [[ -n "$promql_rules_param" ]]; then
      $OPEN "$alert_rules_url" &>/dev/null
    fi
  }

  # For KCS search ----
  cco_search_kcs() {
    local search_header=""
    local search_params='documentKind:("Solution")'
    local api_url_pattern="https://api.access.redhat.com/support/search/kcs?fq=P_DATA&q=Q_DATA&rows=3&start=0"

    inc_separator
    echo
    echo -e "${YEL}Searching for KCS Solutions...${NC}"

    if [[ ${#search_strings[@]} -eq 0 ]]; then

      echo -e "${GRN}Couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources related to cloud-credential pods${NC}"
      return 1
    fi
    for issue in "${!search_strings[@]}"; do
      issue="${issue##*:}"
      compiled_search="$search_header $issue"
      compiled_search_encoded=$(jq -rn --arg x "$compiled_search" '$x|@uri')
      search_params_encoded=$(jq -rn --arg x "$search_params" '$x|@uri')

      api_url="$api_url_pattern"
      api_url=${api_url//P_DATA/$search_params_encoded}
      api_url=${api_url//Q_DATA/$compiled_search_encoded}

      echo -e "\nDetected issue: ${YEL}$issue${NC}"
      echo -e "Suggested KCS solution(s):"

      kcs_solutions=$(curl -s -u "$username:$password" "$api_url" | jq -r '.response.docs | .[] | .view_uri')
      echo -e "${GRN}${kcs_solutions:-Nothing was found}${NC}"
      echo -e ""
    done
  }

  run_cloud_credential_operator() {
    cco_status
    cco_pods
    cco_resource
    cco_pod_logs
    cco_search_kcs
    cco_get_prometheus_graph_links "openshift-cloud-credential-operator"
    print_additional_info "forum-cloud-credential-operator"
  }

  cco_status() {
    inc_separator
    local cco_conditions

    inc_title "Checking status for Cloud Credential Operator..."
    oc get co cloud-credential
    cco_conditions=$(oc get co cloud-credential -o json | jq '.status | {status: {"conditions"}} | .status.conditions |= sort_by(.lastTransitionTime) | .status.conditions |= reverse')

    formatted_cco_conditions=$(print_json $cco_conditions | sed -e "s/Degraded/${BRED}&${NC}/g")
    echo -e "$formatted_cco_conditions"

    degraded_messages=$(echo "$cco_conditions" | jq '.status.conditions | .[] | select(.type == "Degraded" and .status == "True") | .message')
    progressing_messages=$(echo "$cco_conditions" | jq '.status.conditions | .[] | select(.type == "Progressing" and .status == "True") | .message')

    if [[ -n $degraded_messages ]]; then
      error_messages=$(echo -e "$degraded_messages" | head -n 1)
    elif [[ -n $progressing_messages ]];then
      error_messages=$(echo -e "$progressing_messages" | head -n 1)
    fi

    while IFS= read -r err_msg; do
      if [[ -n $err_msg ]]; then search_strings["$err_msg"]=1; fi
    done <<< "$error_messages"

  }

  cco_pods() {
    inc_separator
    inc_title "Checking pods status for Cloud Credential Operator..."
    oc -n openshift-cloud-credential-operator get pods
  }

  cco_resource() {
    inc_separator
    inc_title "Checking cloud credential resource.."
    oc get cloudcredential cluster -o yaml
  }

  cco_pod_logs() {
    inc_separator
    default_logs=15

    inc_title "Gathering pod logs for Cloud Credential Operator..."
    pod_logs=$(oc -n openshift-cloud-credential-operator logs --tail=$default_logs deployment/cloud-credential-operator -c cloud-credential-operator)

    if [[ -z $pod_logs ]]; then
      echo -e "\n${YEL}No logs were found\nskipping ...${NC}"
      return 1
    fi

    formatted_pod_logs=$(format_logs "$pod_logs")
    echo -e "$formatted_pod_logs"

    while true; do
    echo -e "\n"
    read -p "Do you want to open the full logs (y/n)? " logs_answer
      case $logs_answer in
        [yY])
          echo -e "${GRN}Collecting the full logs ..${NC}"

          # #For full logs (1000 logs)
          full_pod_logs=$(oc -n openshift-cloud-credential-operator logs --tail=1000 deployment/cloud-credential-operator -c cloud-credential-operator 2>&1)
          formatted_full_pod_logs=$(format_logs "$full_pod_logs")
          echo -e "$formatted_full_pod_logs" | less -r
          echo -e "${GRN}The full logs window has been closed.${NC}"
          break
        ;;
        [nN])
          break
        ;;
        *)
          echo -e "${YEL}Invalid input. Please answer (y)es or (n)o${NC}"
        ;;
      esac
    done

    # For KCS search strs of logs ----
    logs_search_patterns=("CredentialsProvisionFailure" "InsufficientCloudCreds" "ebs-cloud-credentials not found" "disabled" "empty awsSTSIAMRoleARN" "InvalidClientTokenId" "unable to read info for username")
    for search_str in "${logs_search_patterns[@]}"; do
      local err_logs=$(grep --color=never -F "${search_str}" <<< ${full_pod_logs:-$pod_logs})
      if [[ -z $err_logs ]]; then continue; fi

      while IFS= read -r line; do
        err_msg=$(echo $line | grep -m 1 -o 'msg="[^"]*"')
        err_msg=${err_msg#msg=\"} ; err_msg=${err_msg%\"}
        search_strings["$err_msg"]=1
      done <<< "$err_logs"
    done
  }

  main() {
    if [[ -z $cluster_id ]]; then echo -e "${YEL}missing cluster ID${NC}"; exit 1; fi
    os_default_browser
    inc_login
    get_basic_info
    run_cloud_credential_operator
  }

  main
}

# :command.function
inceptor_check_ingress_command() {
  # src/check_ingress_command.sh
  #!/bin/bash

  # clear the terminal
  clear

  # Set color codes for formatting terminal output
  RED="\033[1;31m"
  GREEN="\033[1;32m"
  YELLOW="\033[1;33m"
  BLUE="\033[1;44m"
  RESET="\033[0m"

  # Assign the first command-line argument to the variable 'cluster_id'
  cluster_id="${args[clusterid]:-$1}"

  # Initialize a search string for Knowledge Center Search
  search_string="ingress+controller+%2B+operator+%2B+openshift"
  # - q=ingress+controller+%2B+openshift+in+"access.redhat.com%2Fsolutions"
  # - q=ingress+controller+%2B+openshift+in+"access.redhat.com%2Farticles"
  # - q=ingress+controller+%2B+operator+%2B+openshift+in+"access.redhat.com%2Fsolutions"
  # - q=ingress+controller+%2B+operator+%2B+openshift+in+"access.redhat.com%2Farticles"

  # Set a flag to indicate whether to perform Knowledge Center Search
  do_kcs_search="true"

  echo
  echo

  # ===============================================================================================
  # =============================== FUNCTION Definition Start ====================================

  # Define a function to login.
  do_login() {
          # Read the input from the user and store it in the variable 'username'
          echo -n "Enter your username (ex: rhn-support-<kerberos>): "
          read username

          # Prompt the user to enter their password (with the '-s' flag to silence input)
          # Read the input from the user without echoing it to the terminal (for password input)
          echo -n "Enter your password: "
          read -s pass

          echo
          echo
          echo -e "${YELLOW}Logging into the cluster via backplane...${RESET}"

          # Use 'ocm backplane login' command to log into the cluster using the provided 'cluster_id'
          ocm backplane login $cluster_id
          echo
  }

  # Define a function named 'get_basic_info'
  get_basic_info() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo
      echo -e "${YELLOW}Listing basic information about the cluster...${RESET}"
      echo

      # Use 'osdctl cluster context' command to display cluster context using the provided 'cluster_id'
      osdctl -S cluster context $cluster_id

      echo

      # Echo a separator line in green color for visual distinction
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo

      echo -e "${YELLOW}Listing the service logs sent in past 30 days...${RESET}"

      # Use 'osdctl servicelog list' command to list service logs for the provided 'cluster_id'
      osdctl -S servicelog list $cluster_id

      echo

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo

      echo -e "${YELLOW}Checking cluster version, node and all cluster operator status...${RESET}"
      echo
      oc get clusterversion; echo; echo; oc get nodes; echo; echo; oc get co

      echo

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Function to check ingress cluster operator status.
  check_ingress_cluster_operator_status() {
      echo

      echo -e "${YELLOW}Checking Ingress Operator Status...${RESET}"

      # Use 'oc get co ingress' command to get the status of the Ingress Cluster Operator
      echo
      oc get co ingress
      echo

      # Provide information about the '.status.conditions' section and its significance
      echo -e "The below ${GREEN}'.status.conditions'${RESET} section provides insights into the overall health and operational state of the Operator."

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo

      # Use 'oc describe co ingress' command to get detailed information about the Ingress Cluster Operator
      # Pipe the output to 'awk' to filter and print the relevant '.status.conditions' section
      oc describe co ingress | awk '/^\s*Conditions:/, /^\s*Extension:/{if(/^\s*Extension:/) exit; print}'

      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo
  }

  # Function to check the deployment and pods for ingress
  check_ingress_cluster_operator_resources() {

      echo -e "${YELLOW}Checking the deployment and pods in openshift-ingress namespace...${RESET}"
      echo

      echo -e "${GREEN}DEPLOYMENT:${RESET}"

      # Use 'oc' command to get deployments in the namespace 'openshift-ingress'
      oc -n openshift-ingress get deployments

      echo
      echo

      echo -e "${GREEN}PODS:${RESET}"

      # Use 'oc' command to get pods in the namespace 'openshift-ingress'
      oc -n openshift-ingress get pods

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo

      echo -e "${YELLOW}Checking the deployment and pods in openshift-ingress-operator namespace...${RESET}"
      echo

      echo -e "${GREEN}DEPLOYMENT:${RESET}"

      # Use 'oc' command to get deployments in the namespace 'openshift-ingress'
      oc -n openshift-ingress-operator get deployments

      echo
      echo

      echo -e "${GREEN}PODS:${RESET}"

      # Use 'oc' command to get pods in the namespace 'openshift-ingress'
      oc -n openshift-ingress-operator get pods

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo
  }

  # Function to check the namespace events for ingress
  check_ingress_cluster_operator_events(){

      echo -e "${YELLOW}Listing events from namespace/openshift-ingess${RESET}"
      echo

      # Use 'oc get events' command to get events in namespace 'openshift-ingess'
      oc get events -n openshift-ingress

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo
      echo

      echo -e "${YELLOW}Listing events from namespace/openshift-ingess-operator .. ${RESET}"

      echo

      # Use 'oc get events' command to get events in namespace 'openshift-ingess'
      oc get events -n openshift-ingress-operator

      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  # Function to gather all Ingress related Pod Logs
  check_ingress_cluster_operator_pod_logs() {

      echo

      echo -e "${YELLOW}Gathering openshift-ingress Pod Logs...${RESET}"
      echo

      # Get the name of the openshift-ingress pod
      oi_pod=$(oc -n openshift-ingress get pods --no-headers -o custom-columns=":metadata.name")

      # Define red flags indicating potential issues in logs
      red_flags=("issue" "error" "degrade" "timeout" "expire" "not responding" "overload" "canceled" "RequestError" "Unavailable" "backoff" "failed" "unreachable" "x509" "connection error" "reconciliation failed" "not created" "conflict" "bottleneck" "congestion" "drop" "spike" "imbalance" "misconfiguration")

      # Check if the pods exist
      if [ -n "$oi_pod" ]; then

          for pod in $oi_pod; do
              # Echo the name of the operator pod
              echo
              echo -e "${GREEN}INGRESS POD NAME: $pod${RESET}"
              echo

              # Get the last 10 lines of logs from the operator pod and filter them for red flags
              log_output=$(oc --tail 20 logs -n openshift-ingress "$pod" | grep -iE 'issue|error|degrade|timeout|expire|overload|canceled|RequestError|Unavailable|backoff|failed|unreachable|x509|not created|conflict|congestion|misconfigur')

              # Colorize the logs containing red flags
              colored_logs="$log_output"
              for word in "${red_flags[@]}"; do
                  colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
              done

              # Print the colorized logs
              echo -e "$colored_logs"
          done
      else
          # Echo a message if no operator pod is found
          echo "No Ingress pods found."
      fi

      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo

      echo -e "${YELLOW}Gathering openshift-ingress-operator Pod Logs...${RESET}"
      echo

      # Get the name of the openshift-ingress-operator pod
      oio_pod=$(oc -n openshift-ingress-operator get pods --no-headers -o custom-columns=":metadata.name")

      # Check if the pods exist
      if [ -n "$oio_pod" ]; then

          for pod in $oio_pod; do
              # Echo the name of the operator pod
              echo
              echo -e "${GREEN}INGRESS OPERATOR POD NAME: $pod${RESET}"
              echo

              # Get the last 10 lines of logs from the operator pod and filter them for red flags
              log_output=$(oc --tail 10 logs -n openshift-ingress-operator "$pod" | grep -iE 'issue|error|degrade|timeout|expire|overload|canceled|RequestError|Unavailable|backoff|failed|unreachable|x509|not created|conflict|congestion|misconfigur')

              # Colorize the logs containing red flags
              colored_logs="$log_output"
              for word in "${red_flags[@]}"; do
                  colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
              done

              # Print the colorized logs
              echo -e "$colored_logs"
          done
      else
          # Echo a message if no operator pod is found
          echo "No Ingress Operator pod found."
      fi

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Function to check other configurations related to ingess
  check_ingress_controller_status() {
      echo

      ics=$(oc get ingresscontroller -n openshift-ingress-operator --no-headers -o custom-columns=":metadata.name")

      # Split the output into an array using newline as delimiter
      IFS=$'\n' read -r -d '' -a ics_array <<<"$ics"

      if [ -n "$ics_array" ]; then

          for ic in "${ics_array[@]}"; do
              # Echo the name of the Ingress Controllers
              echo -e "${GREEN}INGRESS CONTROLLER NAME: $ic${RESET}"
              echo

              # Provide information about the '.status.conditions' section and its significance
              echo -e "The below ${GREEN}'.status.conditions'${RESET} section provides insights into the overall health and operational state of the Operator."

              # Pipe the output to 'awk' to filter and print the relevant '.status.conditions' section
              oc describe ingresscontroller $ic -n openshift-ingress-operator | awk '/^\s*Conditions:/, /^\s*Extension:/{if(/^\s*Extension:/) exit; print}'

              echo
              echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
              echo

          done

      else
          echo "No Ingress Controllers found."
      fi

  }

  # Function to build search string and find KCS based on operator degraded message

  get_kcs() {

      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      operator_degraded_message=$(oc get co ingress -o json | jq -r '.status.conditions[] | select(.type == "Degraded" and .status == "True") | .message')
      if [ -z "$operator_degraded_message" ]; then
          operator_degraded_message=$(oc get co ingress -o json | jq -r '.status.conditions[] | select(.type == "Progressing" and .status == "True") | .message')
      fi

      #echo -e "OPERTOR MESSAGE : $operator_degraded_message"

      if [ -z "$operator_degraded_message" ]; then
          do_kcs_search="false"
      else
          # Strings to search for
          search_pattern=("IngressControllerUnavailable" "SyncLoadBalancerFailed" "issue" "error" "degrade" "timeout" "expire" "not responding" "canceled" "RequestError" "Unavailable" "backoff" "failed" "unreachable" "x509" "connection error" "reconciliation failed" "misconfigur")

          # Variable to store the found strings
          found_strings=""

          # Loop through each search string
          for search_str in "${search_pattern[@]}"; do
              # Check if the search string is present in the paragraph
              if [[ $operator_degraded_message =~ $search_str ]]; then
                  # If found, append it to the variable
                  found_strings="$found_strings $search_str"
              fi
          done

          updated_operator_degraded_message=$(echo "$found_strings" | sed 's/ /%20/g')
          updated_search_string="$search_string$updated_operator_degraded_message"

      fi

      echo

      disclaimer="Content retrieved via this service may not fully address your specific concerns. Please verify information manually before implementing any suggestions. As we are in the development phase, your understanding is appreciated. Thank you."

      if [ "$do_kcs_search" == "false" ]; then

          echo -e "${GREEN}We couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources manually.${RESET}"

          # page1=https://access.redhat.com/solutions?title=ingress&product=91541&category=All&state=published&kcs_state=All&language=en&field_internal_tags_tid=All

          # page2=https://access.redhat.com/articles?title=ingress&kcs_article_type=All&product=91541&category=All&language=en&order=state&sort=desc

      else
          echo -e "${YELLOW}Searching for KCS Solutions...${RESET}"

          api_url_primary="https://api.access.redhat.com/support/search/kcs?fq=documentKind:(%22Solution%22)&q=*$updated_search_string*&rows=3&start=0"

          api_url_secondary="https://api.access.redhat.com/support/search/kcs?fq=documentKind:(%22Solution%22)&q=*$search_string*&rows=3&start=0"

  	    # Make the API call and store the response in a variable
          KCS=$(curl -s -X GET -u "$username:$pass" "$api_url_primary" | grep -o 'https://access.redhat.com/solutions/[^ ]*' | sed -e 's/["}].*//')

          if [ -z "$KCS" ]; then
             KCS=$(curl -s -X GET -u "$username:$pass" "$api_url_secondary" | grep -o 'https://access.redhat.com/solutions/[^ ]*' | sed -e 's/["}].*//')
          else
              # KCS is not empty
              # good to proceed
              echo
          fi

          # Check if the API call was successful (HTTP status code 200)
          http_status_codep=$(curl -s -o /dev/null -w "%{http_code}" "$api_url_primary")
          http_status_codes=$(curl -s -o /dev/null -w "%{http_code}" "$api_url_secondary")

          if [ "$http_status_codep" -eq 200 ] || [ "$http_status_codes" -eq 200 ] ; then
              echo "Heya! we found some KCS for you : "
              echo $KCS | sed 's/ /\n/g'
              echo
              echo $disclaimer
              echo
          else
              echo "We apologise, the API request for 'KCS Search' has been failed with HTTP status code $http_status_code."
          fi
      fi
  }

  # Function to display any additional information
  other_info() {
      echo
      echo "For further concerns you can reach out to the SRE or cloudy or regional channel. Additionally, you can check the other network configurations such as certificates, loadbalancer configurations and check other cluster operators too ..."
      echo
      echo "Thank you for trying our service, hope to serve you the best!"
      echo
      ocm backplane logout &> /dev/null
  }

  # Main function
  main() {

      # perform cluster login, basic checks.
      do_login
      get_basic_info

      # start looking into ingress things
      check_ingress_cluster_operator_status
      check_ingress_cluster_operator_resources
      check_ingress_cluster_operator_events

      # dig deep into ingress
      check_ingress_cluster_operator_pod_logs
      check_ingress_controller_status

      # Build KCS search string, search for KCS solutions and some other info + log out from cluster.
      get_kcs
      other_info

  }

  # =============================== FUNCTION Definition END ====================================

  # ================================ MAIN FUNCTION Invoke ======================================

  # Call the main function to start the program execution
  main
}

# :command.function
inceptor_check_cluster_health_command() {
  # src/check_cluster_health_command.sh
  #!/bin/bash

  cluster_id="${args[clusterid]}"

  ocm backplane login $cluster_id

  jobDetails=$(ocm backplane managedjob create CEE/cluster-health-check)

  while read -r line; do
      # Check if the line contains "ocm backplane managedjob get"
      if [[ $line == *"ocm backplane managedjob get openshift-job-"* ]]; then
          # If found, store it in check_job_status variable
          check_job_status="$line"
          break  # Exit loop after finding the first occurrence
      fi
  done <<< "$jobDetails"

  while read -r line; do
      # Check if the line contains "ocm backplane managedjob get"
      if [[ $line == *"ocm backplane managedjob logs openshift-job-"* ]]; then
          # If found, store it in check_job_status variable
          get_logs="$line"
          break  # Exit loop after finding the first occurrence
      fi
  done <<< "$jobDetails"

  check_status() {
      # Run the command and store the output in a variable
      jobGetOutput=$(eval "$check_job_status")

      # Extract the STATUS field using awk
      status=$(echo "$jobGetOutput" | awk 'NR==2{print $2}')

      # Return the status
      echo "$status"
  }

  # Loop until status is "Succeeded"
  while true; do
      # Check the status
      status=$(check_status)

      # Check if status is "Succeeded"
      if [ "$status" = "Succeeded" ]; then
          echo "Job Status is Succeeded. Checking job logs..."
          eval "$get_logs"
          break  # Exit the loop
      else
          echo "Waiting for status to be Succeeded..."
          sleep 15  # Wait for some time before checking again
      fi
  done
}

# :command.function
inceptor_check_machines_command() {
  # src/check_machines_command.sh
  #!/bin/bash

  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  BLUE="\033[44m"
  RESET="\033[0m"
  cluster_id="${args[clusterid]:-$1}"

  # Function to login to the cluster via backplane
  login_via_backplane() {
      echo -e "${YELLOW}Logging into the cluster via backplane...${RESET}"
      ocm backplane login $cluster_id
      if [ $? -ne 0 ]; then
          echo -e "${RED}Failed to log into the cluster via backplane. Exiting script.${RESET}"
          exit 1
      fi
  }

  # Function to check MachineSet status
  check_machineset_status() {
    echo -e "\n${GREEN}Fetching MachineSet status...${RESET}"
    oc -n openshift-machine-api get machinesets
  }

  # Function to check Machine status
  check_machine_status() {
    echo -e "\n${GREEN}Fetching Machine status...${RESET}"
    oc -n openshift-machine-api get machines
  }

  # Function to check Node status
  check_node_status() {
    echo -e "\n${GREEN}Fetching Node status...${RESET}"
    oc get nodes
  }

  # Function to check pending CSRs
  check_pending_csrs() {
    echo -e "\n${GREEN}Checking for pending CSRs...${RESET}"
    oc get csr | grep Pending
  }

  # Function to troubleshoot a specific machine
  troubleshoot_machine() {
    local machine_name=$1

    echo -e "\n${GREEN}Starting troubleshooting for machine: $machine_name ${RESET}"

    # Check if the machine is stuck in Provisioned status
    status=$(oc -n openshift-machine-api get machine "$machine_name" -o jsonpath='{.status.phase}')
    if [[ $status == "Provisioned" ]]; then
      echo -e "Machine is in ${YELLOW}'Provisioned'${RESET} status. Checking for EC2 instance and machine-config-daemon logs..."

      echo -e "\n${GREEN}Checking machine-config-daemon logs for errors:${RESET}"
      for POD in $(oc -n openshift-machine-config-operator get pods -o name | grep machine-config-daemon); do
        oc -n openshift-machine-config-operator logs $POD -c machine-config-daemon | grep Error
      done

      echo -e "\n${GREEN}Recommendation:${RESET} If a failed pull is detected, and the registry is online, delete the Machine."
    fi

    # Check if the machine is in Deleting status
    if [[ $status == "Deleting" ]]; then
      echo -e "Machine is in ${RED}'Deleting'${RESET} status. Checking machine-controller logs..."
      oc logs -n openshift-machine-api deploy/machine-api-controllers -c machine-controller --since=10m | grep "$machine_name"

      echo -e "\n${GREEN}Recommendation:${RESET} If the error relates to a pod that can't be evicted, try manually draining the node:"
      echo -e "\nIf draining fails, manually delete stuck pods until the drain/machine delete completes."
    fi

    # Check if the machine status is Failed or Provisioning
    if [[ $status == "Failed" || $status == "Provisioning" || $status == "Running" ]]; then
      echo -e "Machine is in ${YELLOW}'$status'${RESET} status. Checking machine-controller logs..."

      # Check machine-controller logs for error details
      oc logs -n openshift-machine-api deploy/machine-api-controllers -c machine-controller --since=10m | grep "$machine_name"

      # Machine Status:
      echo -e "${GREEN}Machine status:${RESET}"
      oc describe machine "$machine_name" -n openshift-machine-api | grep -A 20 "Status:"

      # Get the AWS instance ID for the machine
      instance_id=$(oc describe machine "$machine_name" -n openshift-machine-api | grep "Instance Id" | awk '{print $3}')

      # AWS cloud console link:
      echo
      ocm backplane cloud console

      echo
      echo -e "\n${GREEN}Recommendation:${RESET} To further check the issue, navigate to AWS console -> EC2 -> check if the EC2 instance is present."
      echo -e "If the associated EC2 instance is not present in the AWS console, check the cloud trail event history for the Instance Id ($instance_id)."
    fi
  }

  # Main menu for the interactive script

  login_via_backplane

  while true; do
    echo -e "\n${GREEN}OpenShift Machine Troubleshooting Script${RESET}"
    echo -e "${YELLOW}1. Check MachineSet status${RESET}"
    echo -e "${YELLOW}2. Check Machine status${RESET}"
    echo -e "${YELLOW}3. Check Node status${RESET}"
    echo -e "${YELLOW}4. Check pending CSRs${RESET}"
    echo -e "${YELLOW}5. Troubleshoot a specific machine${RESET}"
    echo -e "${YELLOW}6. Exit${RESET}"
    read -p "Enter your choice [1-6]:" choice

    case $choice in
      1)
        check_machineset_status
        ;;
      2)
        check_machine_status
        ;;
      3)
        check_node_status
        ;;
      4)
        check_pending_csrs
        ;;
      5)
        check_machine_status
        read -p "Enter the name of the machine to troubleshoot: " machine_name
        troubleshoot_machine "$machine_name"
        ;;
      6)
        echo "Exiting script. Goodbye!"
        break
        ;;
      *)
        echo "Invalid choice. Please select a valid option."
        ;;
    esac

  done
}

# :command.function
inceptor_setup_case_summarizer_command() {
  # src/setup_case_summarizer_command.sh
  #!/bin/bash

  set -e

  github_url="https://raw.githubusercontent.com/kkulshreshth/inceptor/refs/heads/main/inceptor-cli/caseSummaryGenerator.py"

  output_path="$HOME/caseSummaryGenerator.py"

  # Function to install Python packages using pip on RHEL
  install_python_packages_rhel() {
    echo "Installing Python on RHEL..."
    sudo dnf install -y python3
    echo "Installing python-pip on RHEL..."
    sudo dnf install -y python3-pip
    echo
    echo "Checking Python and pip version..."
    python3 --version
    pip3 --version
    echo
    echo "Installing Python packages langchain-community and langchain-core..."
    pip3 install langchain-community langchain-core
  }

  # Function to install Python packages using pip on macOS
  install_python_packages_macos() {
    echo "Installing Python using Homebrew on macOS..."
    brew install python
    echo

    echo "Installing virtualenv..."
    pipx install virtualenv
    echo

    echo "Creating a virtual environment..."
    python3 -m venv inceptor_venv

    echo "Activating the virtual environment..."
    source inceptor_venv/bin/activate

    echo "Checking Python and pip version inside the virtual environment..."
    python3 --version
    pip3 --version
    echo

    echo "Installing Python packages langchain-community and langchain-core inside the virtual environment..."
    pip3 install langchain-community langchain-core pip requests

    echo "Virtual environment setup complete. The virtual environment will be activated for the following operations."

    # Keep the virtual environment active
    export VIRTUAL_ENV=active

  }

  # Function to copy Python script from GitHub
  copy_python_script() {
    github_url=$1
    output_path=$2

    echo "Downloading from GitHub: $github_url..."
    curl -L "$github_url" -o "$output_path"

    # Check if curl command succeeded
    if [ $? -eq 0 ]; then
        echo "Download successful. File saved to: $output_path"
    else
        echo "Failed to download the file from GitHub: $github_url"
        exit 1
    fi
  }

  # Function to install Ollama's software on RHEL
  install_ollama_rhel() {
    echo "Installing Ollama software on RHEL..."
    curl -fsSL https://ollama.com/install.sh | sh
  }

  # Function to install Ollama's software on macOS
  install_ollama_macos() {
    url="https://ollama.com/download/Ollama-darwin.zip"
    temp_zip="/tmp/Ollama-darwin.zip"  # Temporary location to store the downloaded ZIP
    install_dir="/Applications"       # Directory to install Ollama (adjust as needed)

    echo "Downloading Ollama from $url..."
    curl -L -o "$temp_zip" "$url"

    # Check if curl command succeeded
    if [ $? -ne 0 ]; then
        echo "Failed to download Ollama from $url"
        exit 1
    fi

    echo "Extracting Ollama package..."
    unzip -q "$temp_zip" -d "$install_dir"

    # Check if unzip command succeeded
    if [ $? -ne 0 ]; then
        echo "Failed to extract Ollama package"
        exit 1
    fi

    echo "copying ollama to /usr/local/bin"
    sudo ln -s /Applications/Ollama.app/Contents/Resources/ollama /usr/local/bin/ollama

    echo "Cleaning up..."
    rm "$temp_zip"

    echo "Ollama installation completed successfully."
  }

  # Function to pull the wizardlm2 model using Ollama
  pull_wizardlm2_model() {
    echo "Pulling wizardlm2 model..."
    ollama pull wizardlm2
  }

  # Ask the user for the operating system
  echo "Please select your operating system:"
  echo "1) RHEL"
  echo "2) MacOS"
  read -p "Enter the number corresponding to your OS (1 or 2): " os_choice

  # Execute the functions based on OS choice
  if [ "$os_choice" == "1" ]; then
    echo "You selected RHEL."
    install_python_packages_rhel
    copy_python_script "$github_url" "$output_path"
    install_ollama_rhel
    pull_wizardlm2_model
  elif [ "$os_choice" == "2" ]; then
    echo "You selected macOS."
    install_python_packages_macos
    #copy_python_script "$github_url" "$output_path"
    #install_ollama_macos
    #pull_wizardlm2_model
  else
    echo "Invalid selection. Please run the script again and choose either 1 or 2."
    exit 1
  fi

  echo "Installation completed successfully."
}

# :command.function
inceptor_summarize_command() {
  # src/summarize_command.sh
  #!/usr/bin/env bash

  # Auto-generated by Bashly v0.9.5
  # https://bashly.dannyb.co/
  # DO NOT EDIT THIS FILE DIRECTLY. INSTEAD, EDIT THE YAML CONFIGURATION FILE AND REGENERATE.

  case_id="${args[caseid]:-$1}"

  command_summarize_case() {
    # Prompt user to select OS
    echo "Which operating system are you using?"
    echo "1. RHEL"
    echo "2. MacOS"
    read -p "Enter your choice (1 or 2): " os_choice

    case $os_choice in
      1)
        # Execute on RHEL (Assuming python3 is available)
        if ! command -v python3 &> /dev/null; then
          echo "Python3 is not installed. Please install it to use this command."
          exit 1
        fi

        python3 $HOME/caseSummaryGenerator.py "$case_id"
        ;;
      2)
        if ! command -v python3 &> /dev/null; then
          echo "Python3 is not installed. Please install it to use this command."
          exit 1
        fi

        # Activate venv created in setup-case-summarizer script
        source "inceptor_venv/bin/activate"
        python3 $HOME/caseSummaryGenerator.py "$case_id"
        ;;
      *)
        echo "Invalid choice. Please enter 1 or 2."
        ;;
    esac
  }

  # Main entry point
  command_summarize_case

}

# :command.function
inceptor_upgrade_command() {
  # src/upgrade_command.sh
  #!/bin/bash

  # Define variables
  BIN_NAME="inceptor"
  BIN_PATH="/usr/local/bin/$BIN_NAME"
  GITHUB_REPO="kkulshreshth/inceptor"
  RELEASE_URL="https://api.github.com/repos/kkulshreshth/inceptor/releases/latest"

  # Function to fetch the latest release version from GitHub
  get_latest_version() {
      curl -s "$RELEASE_URL" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/'
  }

  # Function to get the current installed version of the binary
  get_current_version() {
      $BIN_PATH --version 2>/dev/null || echo "none"
  }

  # Function to download and replace the binary
  upgrade_binary() {
      LATEST_VERSION=$1
      DOWNLOAD_URL="https://github.com/$GITHUB_REPO/releases/download/$LATEST_VERSION/$BIN_NAME"

      echo "Downloading the latest version: $latest_version"
      curl -L -o /tmp/$BIN_NAME $DOWNLOAD_URL

      echo "Replacing the old binary with the new one..."
      sudo mv /tmp/$BIN_NAME $BIN_PATH
      sudo chmod +x $BIN_PATH

      echo "Upgrade complete. You are now running version $LATEST_VERSION."
  }

  # Get the latest and current versions
  latest_version=$(get_latest_version)
  current_version_temp=$(get_current_version)
  current_version="v$current_version_temp"

  echo "Current version: $current_version"
  echo "Latest version: $latest_version"

  # Compare versions and decide if an upgrade is needed
  if [ "$current_version" = "$latest_version" ]; then
      echo "You are already on the latest version."
  else
      echo "A new version is available. Upgrading from $current_version to $latest_version..."
      upgrade_binary "$latest_version"
  fi
}

# :command.function
inceptor_collect_must_gather_command() {
  # src/collect_must_gather_command.sh
  #!/bin/bash

  # Script to extract the token from the JSON response using curl and jq

  # STEP-1:

  # Login to cluster via backplane
   GREEN="\033[32m"
   RESET="\033[0m"
   clusterID="${args[clusterid]:-$1}"

  echo -e "${GREEN}Logging into the cluster via backplane...${RESET}"
  ocm backplane login $clusterID

  # Collect info
  echo "Enter your username (ex: rhn-support-<kerberos>):"
  read USERNAME

  echo "Enter support case ID:"
  read caseID

  secret_name=case-management-creds

  # STEP-2:

  echo
  echo -e "${GREEN}Getting SFTP token...${RESET}"
  echo

  URL="https://access.redhat.com/hydra/rest/v1/sftp/token/upload/temporary"

  # Fetch the JSON response from the server, this will ask for password
  response=$(curl -s -u "$USERNAME" "$URL")

  # Check if the response is not empty and contains valid JSON
  if [[ -n "$response" ]]; then
      # Extract the token using jq
      temp_token=$(echo "$response" | jq -r '.token')

      # Check if the token was successfully extracted
      if [[ -n "$temp_token" ]]; then
          echo "Token extracted successfully."
          echo "Token: $temp_token"
          echo
      else
          echo "Error: Token could not be extracted. Response might be malformed."
          echo "Response: $response"
          echo
      fi
  else
      echo "Error: No response received or the response is empty."
  fi

  # STEP-3:

  URL="https://access.redhat.com/hydra/rest/contacts/sso/$USERNAME"

  echo -e "${GREEN}Checking if your Hydra user isInternal...${RESET}"
  echo

  isInternal=$(curl -s -u "$USERNAME" "$URL" | jq -r .isInternal)
  echo "isInternal: "$isInternal""
  echo

  # STEP-4: Create a secret in the openshift-must-gather-operator namespace

  echo -e "${GREEN}Creating a secret in the openshift-must-gather-operator namespace...${RESET}"
  echo

  oc create secret generic $secret_name --from-literal=username=$USERNAME --from-literal=password=$temp_token -n openshift-must-gather-operator

  # STEP-5: Create a yaml file on your computer

  echo -e "${GREEN}Creating mustgather.yaml file on your computer...${RESET}"

  # Define the output file
  output_file="mustgather.yaml"

  # Create the YAML content with replacements
  cat << EOF > "$output_file"
apiVersion: managed.openshift.io/v1alpha1
kind: MustGather
metadata:
  name: ${caseID}-must-gather
  namespace: openshift-must-gather-operator
spec:
  caseID: '${caseID}'
  caseManagementAccountSecretRef:
    name: ${secret_name}

  serviceAccountRef:
    name: must-gather-admin
  internalUser: ${isInternal}
EOF

  # Notify the user of the created file
  echo "File '$output_file' created successfully with the following content:"
  cat "$output_file"

  # Step 6: Use the yaml file to create a MustGather CR

  echo
  echo -e "${GREEN}Creating Mustgather CR...${RESET}"
  echo
  oc apply -f mustgather.yaml -n openshift-must-gather-operator

  # Step 7: Wait for pod in openshift-must-gather-operator namespace to be marked as Completed

  echo -e "${GREEN}Watching and waiting for the pods in openshift-must-gather-operator namespace to be marked as Completed...${RESET}"
  echo
  oc get pods -n openshift-must-gather-operator -w

}

# :command.function
inceptor_analyze_pcap_command() {
  # src/analyze_pcap_command.sh
  #!/bin/bash
  set -e

  function check_dependencies() {
      local missing_dependencies=()

      if ! command -v tshark &> /dev/null; then
          missing_dependencies+=("TShark")
      fi

      if ! command -v zenity &> /dev/null; then
          missing_dependencies+=("Zenity")
      fi

      if [ ${#missing_dependencies[@]} -eq 0 ]; then
          return 0
      else
          echo -e "The following dependencies are missing:"
          for dep in "${missing_dependencies[@]}"; do
              # Using ANSI color codes for red text
              echo -e "\033[31m- $dep\033[0m"
          done
          exit 1
      fi
  }

  function welcome_message() {
      if zenity --question --text="Welcome to Inceptor - PCAP Analyzer =) \n Would you like to analyze a pcap file? "
      then
          return 0
      else
          echo "User chose not to proceed."
          exit 1
      fi
  }

  function select_pcap() {
      pcapName=$(zenity --file-selection --title="Select the pcap file you want to analyze." --file-filter="*.pcap")
      if [ -z "$pcapName" ]
      then
          echo "Error: No pcap file selected." >&2
          exit 1
      fi
      echo $pcapName
  }

  function create_directories() {
      mkdir -p PCAP_Analysis/{Logins,IP_Info,MAC_Addresses,Objects,Emails,HTTP_Requests,Protocols}
  }

  function extract_logins() {
      pcapName=$1
      tshark -r "$pcapName" | grep --color=always -i -E 'auth|denied|login|user|usr|success|psswd|pass|pw|logon|key|cipher|sum|token|pin|code|fail|correct|restrict' > ./PCAP_Analysis/Logins/possible_logins.txt
      tshark -Q -z credentials -r "$pcapName" > ./PCAP_Analysis/Logins/credentials.txt
  }

  function extract_ip_info() {
      pcapName=$1
      tshark -Q -r "$pcapName" -T fields -e ip.src -e ip.dst | grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}' | sort | uniq -c | sort -n -r > ./PCAP_Analysis/IP_Info/all_addresses.txt
      tshark -Q -r "$pcapName" -T fields -e ip.src | grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}' | sort | uniq -c | sort -n -r > ./PCAP_Analysis/IP_Info/source_addresses.txt
      tshark -Q -r "$pcapName" -T fields -e ip.dst | grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}' | sort | uniq -c | sort -n -r > ./PCAP_Analysis/IP_Info/destination_addresses.txt
  }

  function extract_mac_addresses() {
      pcapName=$1
      # Run tshark to get the ethernet endpoint information
      tshark -Q -nqr "$pcapName" -z endpoints,eth | \

      # Format the output into CSV
      awk '
      BEGIN {
          # Print CSV header
          print "MAC Address,Total Packets,Total Bytes,Tx Packets,Tx Bytes,Rx Packets,Rx Bytes"
      }
      /^[[:space:]]*([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}/ {
          # Extract and print MAC address, Total Packets, Total Bytes, Tx Packets, Tx Bytes, Rx Packets, Rx Bytes
          print $1 "," $2 "," $3 "," $4 "," $5 "," $6 "," $7
      }' > ./PCAP_Analysis/MAC_Addresses/mac_addresses.csv
  }

  function extract_http_requests() {
      pcapName=$1
      tshark -r "$pcapName" -Y http.request -T fields \
      -e frame.number \
      -e frame.time_epoch \
      -e http.request.method \
      -e http.request.uri \
      -e http.host \
      -e http.user_agent \
      -e http.referer \
      -e ip.src \
      -e eth.src \
      -e http.response.code \
      -E header=y \
      -E separator=, \
      -E quote=d \
      -E occurrence=f > ./PCAP_Analysis/HTTP_Requests/http_requests.csv
  }

  function extract_data_to_csv() {
      tshark -r "$pcapName" -T fields \
      -e frame.number \
      -e frame.time_epoch \
      -e eth.src \
      -e eth.dst \
      -e ip.src \
      -e ip.dst \
      -e ipv6.src \
      -e ipv6.dst \
      -e ip.proto \
      -e tcp.srcport \
      -e tcp.dstport \
      -e udp.srcport \
      -e udp.dstport \
      -e frame.len \
      -e _ws.col.Protocol \
      -e _ws.col.Info \
      -E header=y \
      -E separator=, \
      -E quote=d \
      -E occurrence=f > ./PCAP_Analysis/HTTP_Requests/pcap_analysis.csv
  }

  function extract_emails() {
      pcapName=$1
      tshark -r "$pcapName" -T fields -e frame.number -e ip.src | awk '/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b/ {print $0}' > ./PCAP_Analysis/Emails/verbose_email_packets.txt
      tshark -r "$pcapName" | grep --color=always -E "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b" > ./PCAP_Analysis/Emails/email_packets.txt
  }

  function extract_protocols() {
      pcapName=$1
      tshark -r "$pcapName" -T fields -e frame.protocols | sort | uniq -c | sort -n -r > ./PCAP_Analysis/Protocols/protocols.txt
  }

  function analyze_pcap() {
      pcapName=$1
      extract_logins "$pcapName"
      extract_ip_info "$pcapName"
      extract_mac_addresses "$pcapName"
      extract_objects "$pcapName"
      extract_emails "$pcapName"
      extract_http_requests "$pcapName"
      extract_protocols "$pcapName"
  }

  function cleanup() {
      # Test to see if the created files are empty (have zero bytes) with test -s
      test ! -s "./PCAP_Analysis/Emails/email_packets.txt" && rm -f "./PCAP_Analysis/Emails/email_packets.txt"
      test ! -s "./PCAP_Analysis/Emails/verbose_email_packets.txt" && rm -f "./PCAP_Analysis/Emails/verbose_email_packets.txt"
      test ! -s "./PCAP_Analysis/HTTP_Requests/http_requests.txt" && rm -f "./PCAP_Analysis/HTTP_Requests/http_requests.txt"
      test ! -s "./PCAP_Analysis/IP_Info/all_addresses.txt" && rm -f "./PCAP_Analysis/IP_Info/all_addresses.txt"
      test ! -s "./PCAP_Analysis/IP_Info/destination_addresses.txt" && rm -f "./PCAP_Analysis/IP_Info/destination_addresses.txt"
      test ! -s "./PCAP_Analysis/IP_Info/source_addresses.txt" && rm -f "./PCAP_Analysis/IP_Info/source_addresses.txt"
      test ! -s "./PCAP_Analysis/Logins/credentials.txt" && rm -f "./PCAP_Analysis/Logins/credentials.txt"
      test ! -s "./PCAP_Analysis/Logins/possible_logins.txt" && rm -f "./PCAP_Analysis/Logins/possible_logins.txt"
      test ! -s "./PCAP_Analysis/Protocols/protocols.txt" && rm -f "./PCAP_Analysis/Protocols/protocols.txt"

      # Test whether the ./PCAP_Analysis/Objects directory has any files. Delete if empty.
      if [ $(ls -A ./PCAP_Analysis/Objects | wc -l) -eq 0 ]
      then
          rm -rf ./PCAP_Analysis/Objects
      fi
  }

  function finish() {
      sleep 0.5
      tree -s ./PCAP_Analysis
      zenity --info --text="Pcap scan complete. All output is in the 'PCAP_Analysis' directory.\nThanks for using Inceptor!!!\nNOTE - If a directory/file is empty, the program did not find the information."
  }

  function progress_bar() {
      local total=$1
      local current=$2
      local filled=$((current*20/total))
      local empty=$((20-filled))
      echo -ne "\rProgress: [${filled//?/#}${empty//?/-}] $((100*current/total))%"
  }

  function main() {
      check_dependencies
      welcome_message
      pcapName=$(select_pcap)
      create_directories
      progress_bar 7 1
      extract_logins "$pcapName"
      progress_bar 7 2
      extract_ip_info "$pcapName"
      progress_bar 7 3
      extract_mac_addresses "$pcapName"
      progress_bar 7 4
      extract_data_to_csv "$pcapName"
      progress_bar 7 5
      extract_emails "$pcapName"
      progress_bar 7 6
      extract_http_requests "$pcapName"
      progress_bar 7 7
      extract_protocols "$pcapName"
      cleanup
      finish
  }

  main
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        inceptor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    check | c)
      action="check"
      shift
      inceptor_check_parse_requirements "$@"
      shift $#
      ;;

    setup-case-summarizer | setup-cs)
      action="setup-case-summarizer"
      shift
      inceptor_setup_case_summarizer_parse_requirements "$@"
      shift $#
      ;;

    summarize)
      action="summarize"
      shift
      inceptor_summarize_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      inceptor_upgrade_parse_requirements "$@"
      shift $#
      ;;

    collect-must-gather | collect-mg)
      action="collect-must-gather"
      shift
      inceptor_collect_must_gather_parse_requirements "$@"
      shift $#
      ;;

    analyze-pcap)
      action="analyze-pcap"
      shift
      inceptor_analyze_pcap_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      inceptor_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
inceptor_check_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    image-registry | ir)
      action="image-registry"
      shift
      inceptor_check_image_registry_parse_requirements "$@"
      shift $#
      ;;

    authentication | auth)
      action="authentication"
      shift
      inceptor_check_authentication_parse_requirements "$@"
      shift $#
      ;;

    cloud-credential | cc)
      action="cloud-credential"
      shift
      inceptor_check_cloud_credential_parse_requirements "$@"
      shift $#
      ;;

    ingress)
      action="ingress"
      shift
      inceptor_check_ingress_parse_requirements "$@"
      shift $#
      ;;

    cluster-health | ch)
      action="cluster-health"
      shift
      inceptor_check_cluster_health_parse_requirements "$@"
      shift $#
      ;;

    machines)
      action="machines"
      shift
      inceptor_check_machines_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      inceptor_check_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
inceptor_check_image_registry_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_image_registry_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check image-registry"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check image-registry CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_authentication_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_authentication_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check authentication"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check authentication CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_cloud_credential_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_cloud_credential_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check cloud-credential"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check cloud-credential CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_ingress_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_ingress_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check ingress"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check ingress CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_cluster_health_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_cluster_health_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check cluster-health"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check cluster-health CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_machines_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_machines_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check machines"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check machines CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_setup_case_summarizer_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_setup_case_summarizer_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-case-summarizer"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
inceptor_summarize_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_summarize_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="summarize"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['caseid']+x} ]]; then
          args['caseid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['caseid']+x} ]]; then
    printf "missing required argument: CASEID\nusage: inceptor summarize CASEID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_upgrade_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
inceptor_collect_must_gather_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_collect_must_gather_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="collect-must-gather"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor collect-must-gather CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_analyze_pcap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_analyze_pcap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="analyze-pcap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.1"
  long_usage=''

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "check") inceptor_check_command ;;
    "check image-registry") inceptor_check_image_registry_command ;;
    "check authentication") inceptor_check_authentication_command ;;
    "check cloud-credential") inceptor_check_cloud_credential_command ;;
    "check ingress") inceptor_check_ingress_command ;;
    "check cluster-health") inceptor_check_cluster_health_command ;;
    "check machines") inceptor_check_machines_command ;;
    "setup-case-summarizer") inceptor_setup_case_summarizer_command ;;
    "summarize") inceptor_summarize_command ;;
    "upgrade") inceptor_upgrade_command ;;
    "collect-must-gather") inceptor_collect_must_gather_command ;;
    "analyze-pcap") inceptor_analyze_pcap_command ;;
  esac
}

initialize
run "$@"
