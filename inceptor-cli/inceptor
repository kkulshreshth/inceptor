#!/usr/bin/env bash
# This script was generated by bashly 1.1.10 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
inceptor_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor - CLI to troubleshoot ROSA/OSD clusters\n"
    echo

  else
    printf "inceptor - CLI to troubleshoot ROSA/OSD clusters\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  inceptor COMMAND\n"
  printf "  inceptor [COMMAND] --help | -h\n"
  printf "  inceptor --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   troubleshoot operators\n" "check"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
inceptor_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check - troubleshoot operators\n"
    echo

  else
    printf "inceptor check - troubleshoot operators\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check COMMAND\n"
  printf "  inceptor check [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   check image-registry operator\n" "image-registry  "
  printf "  %s   check authentication operator\n" "authentication  "
  printf "  %s   check cloud-credential operator\n" "cloud-credential"
  printf "  %s   check cluster health\n" "cluster-health  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  inceptor check image-registry cluster-id\n"
    echo

  fi
}

# :command.usage
inceptor_check_image_registry_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check image-registry - check image-registry operator\n"
    echo

  else
    printf "inceptor check image-registry - check image-registry operator\n"
    echo

  fi

  printf "Alias: ir\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check image-registry CLUSTERID\n"
  printf "  inceptor check image-registry --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_authentication_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check authentication - check authentication operator\n"
    echo

  else
    printf "inceptor check authentication - check authentication operator\n"
    echo

  fi

  printf "Alias: auth\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check authentication CLUSTERID\n"
  printf "  inceptor check authentication --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_cloud_credential_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check cloud-credential - check cloud-credential operator\n"
    echo

  else
    printf "inceptor check cloud-credential - check cloud-credential operator\n"
    echo

  fi

  printf "Alias: cc\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check cloud-credential CLUSTERID\n"
  printf "  inceptor check cloud-credential --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.usage
inceptor_check_cluster_health_usage() {
  if [[ -n $long_usage ]]; then
    printf "inceptor check cluster-health - check cluster health\n"
    echo

  else
    printf "inceptor check cluster-health - check cluster health\n"
    echo

  fi

  printf "Alias: ch\n"
  echo

  printf "%s\n" "Usage:"
  printf "  inceptor check cluster-health CLUSTERID\n"
  printf "  inceptor check cluster-health --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CLUSTERID"
    printf "    External ID of the ROSA/OSD cluster\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions

# :command.function
inceptor_check_image_registry_command() {
  # src/check_image_registry_command.sh
  #!/bin/bash

  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  BLUE="\033[44m"
  RESET="\033[0m"
  cluster_id="${args[clusterid]}"
  search_string="image%20registry%20operator%20degraded%20in%20OpenShift"
  do_kcs_search="true"

  echo "Enter your username (ex: rhn-support-<kerberos>):"
  read username

  echo "Enter your password:"
  read -s pass

  echo

  login_via_backplane() {
      echo -e "${YELLOW}Logging into the cluster via backplane...${RESET}"
      ocm backplane login $cluster_id
  }

  get_basic_info() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo -e "${YELLOW}Listing basic information about the cluster...${RESET}"
      osdctl cluster context $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Listing the service logs sent in past 30 days...${RESET}"
      osdctl servicelog list $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Checking node status...${RESET}"
      oc get nodes
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Function to check the status of the Image Registry Operator
  check_image_registry_operator_status() {
      echo
      echo -e "${YELLOW}Checking Image Registry Operator Status...${RESET}"
      oc get co image-registry
      echo
      echo -e "The below ${GREEN}'.status.conditions'${RESET} section provides insights into the overall health and operational state of the Operator."
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      oc describe co image-registry | awk '/^\s*Conditions:/, /^\s*Extension:/{if(/^\s*Extension:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  # Checking the deployment and pods for image-registry
  check_operator_resources() {
      echo
      echo -e "${YELLOW}Checking the deployment and pods for image-registry...${RESET}"
      echo -e "${GREEN}DEPLOYMENT:${RESET}"
      oc -n openshift-image-registry get deployments
      echo
      echo
      echo -e "${GREEN}PODS:${RESET}"
      oc -n openshift-image-registry get pod
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  check_image_registry_operator_pod_logs() {
      echo
      echo -e "${YELLOW}Gathering Image Registry Operator Pod Logs...${RESET}"
      operator_pod=$(oc -n openshift-image-registry get pods --no-headers -o custom-columns=":metadata.name" | grep cluster-image-registry-operator)
      red_flags=("error" "degraded" "timeout" "expire" "canceled" "ImagePrunerDegraded" "RequestError" "Unavailable" "backoff" "failed" "x509")

      if [ -n "$operator_pod" ]; then
          echo -e "${GREEN}OPERATOR POD NAME: $operator_pod${RESET}"
          echo
          log_output=$(oc --tail 10 logs -n openshift-image-registry "$operator_pod" | grep -E 'error|failed|degraded|timeout|expire|canceled|Unavailable|backoff|ImagePrunerDegraded|RequestError|x509')
          colored_logs="$log_output"
          for word in "${red_flags[@]}"; do
              colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
          done

          # Print the colored logs
          echo -e "$colored_logs"
      else
          echo "No Image Registry Operator pod found."
      fi
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Checking logs of image-registry pods
  check_image_registry_pod_logs() {
      echo
      echo -e "${YELLOW}Gathering logs from one of the image-registry pods...${RESET}"

      red_flags=("error" "degraded" "timeout" "expire" "canceled" "ImagePrunerDegraded" "RequestError" "Unavailable" "backoff" "failed" "x509")

      echo -e "${GREEN}OPERATOR POD NAME: $operator_pod${RESET}"
      echo
      log_output=$(oc --tail 10 -n openshift-image-registry logs deployment/image-registry | grep -E 'error|failed|degraded|timeout|expire|canceled|Unavailable|backoff|ImagePrunerDegraded|RequestError|x509')
      colored_logs="$log_output"
      for word in "${red_flags[@]}"; do
          colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
      done

      # Print the colored logs
      echo -e "$colored_logs"
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  check_other_configuration() {
      echo
      echo -e "${YELLOW}Listing events from namespace/openshift-image-registry${RESET}"
      oc get events -n openshift-image-registry
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Checking the config for image-registry${RESET}"
      echo -e "${GREEN}oc get configs.imageregistry.operator.openshift.io cluster -o yaml (.status.conditions)${RESET}"
      echo
      oc get configs.imageregistry.operator.openshift.io cluster -o yaml | awk '/^\s*conditions:/, /^\s*generations:/{if(/^\s*generations:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo

      echo -e "${YELLOW}Fetching storage configuration${RESET}"
      echo -e "${GREEN}oc get configs.imageregistry.operator.openshift.io cluster -o json | jq -r '.spec.storage'${RESET}"
      echo
      oc get configs.imageregistry.operator.openshift.io cluster -o json | jq -r '.spec.storage'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"

      echo
      echo -e "${YELLOW}Check imagepruner (.status.conditions)${RESET}"
      echo -e "${GREEN}oc get imagepruner cluster -o yaml (.status.conditions)${RESET}"
      oc get imagepruner cluster -o yaml | awk '/^\s*conditions:/, /^\s*observedGeneration:/{if(/^\s*observedGeneration:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  job_pruning_issues() {
      echo -e "${BLUE}KNOWN ISSUES and SOLUTIONS${RESET}"
      echo -e "${YELLOW}PRUNING JOB FAILURES${RESET}"
      echo
      echo -e "A common cause of the cluster operator to become degraded is through the failure of its periodic pruning jobs."

      echo -e "${GREEN}Check for any jobs which did not complete, they will show up as '0/1' in the completions column${RESET}"
      oc get job -n openshift-image-registry
      echo
      echo -e "If any job did not complete, check the logs for the pod corresponding to the job for more information about the failure using the following command:"
      echo -e "${GREEN}oc logs -n openshift-image-registry -l job-name=$JOBNAME${RESET}"
      echo
      echo -e "If successive pruning jobs have completed, ask the SRE/customer to remove the failed jobs using the following command:"
      echo -e "${GREEN}oc delete job -n openshift-image-registry $JOBNAME${RESET}"
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  print_additional_info() {
      echo
      echo -e "${YELLOW}Additional Information:${RESET}"
      echo -e "To get in touch with OCP engineering for this operator, join ${GREEN}forum-imageregistry${RESET} slack channel and ping ${GREEN}@imageregistry-team${RESET} handle with any queries."
  }

  build_search_string() {
      echo -e "${YELLOW}Building search string${RESET}"
      echo
      operator_degraded_message=$(oc get co image-registry -o json | jq -r '.status.conditions[] | select(.type == "Degraded" and .status == "True") | .message')
      if [ -z "$operator_degraded_message" ]; then
          operator_degraded_message=$(oc get co image-registry -o json | jq -r '.status.conditions[] | select(.type == "Progressing" and .status == "True") | .message')
      fi

      #echo -e "OPERTOR MESSAGE : $operator_degraded_message"

      if [ -z "$operator_degraded_message" ]; then
          do_kcs_search="false"
      else
          # Strings to search for
          search_pattern=("Progressing: Unable to apply resources: unable to sync storage configuration: RequestError: send request failed" "ImagePrunerDegraded: Job has reached the specified backoff limit" "Degraded: The deployment does not have available replicas" "unsupported protocol scheme")

          # Variable to store the found strings
          found_strings=""

          # Loop through each search string
          for search_str in "${search_pattern[@]}"; do
              # Check if the search string is present in the paragraph
              if [[ $operator_degraded_message =~ $search_str ]]; then
                  # If found, append it to the variable
                  found_strings="$found_strings $search_str"
              fi
          done

          # Print the result
          #echo "Found strings: $found_strings"

          updated_operator_degraded_message=$(echo "$found_strings" | sed 's/ /%20/g')
          search_string="$search_string%20$updated_operator_degraded_message"
          #echo "NEW SEARCH STRINGS: $search_string"
          echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      fi
  }

  search_kcs() {
      echo
      if [ "$do_kcs_search" == "false" ]; then
          echo -e "${GREEN}Couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources related to image-regitry pods. You can also refer the following KCS for further troubleshooting:${RESET}${RED} https://access.redhat.com/solutions/3804741${RESET}"
      else
          echo -e "${YELLOW}Searching for KCS Solutions...${RESET}"
          api_url="https://api.access.redhat.com/support/search/kcs?fq=documentKind:(%22Solution%22)&q=*$search_string*&rows=3&start=0"

  	      # Make the API call and store the response in a variable
          api_response=$(curl -s -X GET -u "$username:$pass" "$api_url")

          # Check if the API call was successful (HTTP status code 200)
          http_status_code=$(curl -s -o /dev/null -w "%{http_code}" "$api_url")

          if [ "$http_status_code" -eq 200 ]; then
              echo "API call was successful."
              echo "API Response:"
              echo "$api_response" | grep -o 'https://access.redhat.com/solutions/[^ ]*' | sed -e 's/["}].*//'
          else
              echo "API call failed with HTTP status code $http_status_code."
          fi
      fi
  }

  get_prometheus_graph_links() {
      echo
      echo -e "${YELLOW}Running prometheus queries...${RESET}"
      echo -e "${YELLOW}Please navigate to the following links to review metrics related to the image registry operator:${RESET}"
      echo

      command_to_run="ocm backplane console $cluster_id"

      # Define the file to store the command output
      output_file="console_url_file.txt"

      # Step 1: Open a new terminal, run the command, and store its output
      gnome-terminal -- bash -c "$command_to_run > $output_file; read -n 1 -p 'Press any key to exit.'; exit"

      sleep 60

      console_url=$(grep -o 'http[^\ ]*' $output_file)

      echo -e "${GREEN}1. MONITORING DASHBOARD for namespace/openshift-image-registry: ${RESET}"
      query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=openshift-image-registry&type=deployment"
      echo
      query_url="$console_url/$query"
      echo -e "$query_url"
      echo
      echo -e "${GREEN}2. Query Executed:${RESET} kube_job_status_failed{namespace="openshift-image-registry"}"
      echo -e "This query provides information about the ${GREEN}FAILED${RESET} jobs inside the namespace/openshift-image_registry"
      echo
      query="monitoring/query-browser?query0=kube_job_status_failed%7Bnamespace%3D%22openshift-image-registry%22%7D"
      query_url="$console_url/$query"
      echo -e "$query_url"
      echo
  }

  main() {
      login_via_backplane
      get_basic_info
      check_image_registry_operator_status
      check_operator_resources
      check_image_registry_operator_pod_logs
      check_image_registry_pod_logs
      check_other_configuration
      job_pruning_issues
      build_search_string
      search_kcs
      #get_prometheus_graph_links
      print_additional_info
  }

  main
}

# :command.function
inceptor_check_authentication_command() {
  # src/check_authentication_command.sh
  #!/bin/bash

  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  BLUE="\033[44m"
  RESET="\033[0m"
  cluster_id="${args[clusterid]}"
  search_string="authentication%20operator%20degraded%20in%20OpenShift"
  do_kcs_search="true"

  echo "Enter your username (ex: rhn-support-<kerberos>):"
  read username

  echo "Enter your password:"
  read -s pass

  # Function to login to the cluster via backplane
  login_via_backplane() {
      echo -e "${YELLOW}Logging into the cluster via backplane...${RESET}"
      ocm backplane login $cluster_id
  }

  # Function to get basic info about the cluster
  get_basic_info() {
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo -e "${YELLOW}Listing basic information about the cluster...${RESET}"
      osdctl cluster context $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Listing the service logs sent in past 30 days...${RESET}"
      osdctl servicelog list $cluster_id
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
      echo -e "${YELLOW}Checking node status...${RESET}"
      oc get nodes
      echo
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
  }

  # Function to check the status of the Authentication Operator
  check_authentication_operator() {
      echo
      echo -e "${YELLOW}Checking Authentication Operator Status...${RESET}"
      oc get co authentication
      echo
      echo -e "The below ${GREEN}'.status.conditions'${RESET} section provides insights into the overall health and operational state of the Operator."
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      oc describe co authentication | awk '/^\s*Conditions:/, /^\s*Extension:/{if(/^\s*Extension:/) exit; print}'
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  # Checking the deployment and pods for image-registry
  check_operator_resources() {
      echo
      echo -e "${YELLOW}Checking the deployment and pods for authentication operator...${RESET}"
      echo -e "${GREEN}DEPLOYMENTS:${RESET}"
      oc -n openshift-authentication-operator get deployments
      oc -n openshift-authentication get deployments
      echo
      echo
      echo -e "${GREEN}PODS:${RESET}"
      oc -n openshift-authentication-operator  get pod
      oc -n openshift-authentication get pod
      echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      echo
  }

  # Function to gather Authentication Operator logs.
  get_authentication_operator_logs() {
      echo -e "${YELLOW}Gathering Authentication Operator Pod Logs...${RESET}"
      operator_pod=$(oc get pods -n openshift-authentication-operator -o=jsonpath='{.items[0].metadata.name}')

      red_flags=("error" "degraded" "timeout" "expire" "canceled" "OAuthServerRouteEndpointAccessibleController" "OAuthServerServiceEndpointAccessibleController reconciliation failed" "IngressStateController reconciliation failed")

      if [ -n "$operator_pod" ]; then
          echo -e "${GREEN}OPERATOR POD NAME: $operator_pod${RESET}"
          echo
          log_output=$(oc --tail 500 logs -n openshift-authentication-operator "$operator_pod" | grep -E 'error|failed|degraded|timeout|expire|canceled')

          colored_logs="$log_output"
          for word in "${red_flags[@]}"; do
              colored_logs=$(echo -e "${colored_logs//$word/\\033[31m$word\\033[0m}")
          done

          # Print the colored logs
          echo -e "$colored_logs"
          #print_horizontal_line "-" 120
      else
          echo "No Authentication Operator pod found."
      fi
  }

  # Build keyword search string for searching KCS solutions:
  build_search_string() {
      echo -e "${YELLOW}Building search string${RESET}"
      echo
      operator_degraded_message=$(oc get co authentication -o json | jq -r '.status.conditions[] | select(.type == "Degraded" and .status == "True") | .message')
      if [ -z "$operator_degraded_message" ]; then
          operator_degraded_message=$(oc get co authentication -o json | jq -r '.status.conditions[] | select(.type == "Progressing" and .status == "True") | .message')
      fi

      #echo -e "OPERTOR MESSAGE : $operator_degraded_message"

      if [ -z "$operator_degraded_message" ]; then
          do_kcs_search="false"
      else
          # Strings to search for
          search_pattern=("OAuthServerConfigObservationDegraded: failed to apply IDP" "OAuthServerRouteEndpointAccessibleControllerDegraded" "ProxyConfigControllerDegraded" "APIServerDeploymentDegraded" "OAuthServerConfigObservationDegraded: error validating configMap" "ngressStateEndpointsDegraded: No endpoints found for oauth-server" "RouteStatusDegraded: route is not available")

          # Variable to store the found strings
          found_strings=""

          # Loop through each search string
          for search_str in "${search_pattern[@]}"; do
              # Check if the search string is present in the paragraph
              if [[ $operator_degraded_message =~ $search_str ]]; then
                  # If found, append it to the variable
                  found_strings="$found_strings $search_str"
              fi
          done

          # Print the result
          #echo "Found strings: $found_strings"

          updated_operator_degraded_message=$(echo "$found_strings" | sed 's/ /%20/g')
          search_string="$search_string%20$updated_operator_degraded_message"
          #echo "NEW SEARCH STRINGS: $search_string"
          echo -e "${GREEN}------------------------------------------------------------------------${RESET}"
      fi
  }

  # Search KCS solutions dynamically using hydra API:
  search_kcs() {
      echo
      if [ "$do_kcs_search" == "false" ]; then
          echo -e "${GREEN}Couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources related to oauth pods. You can also refer the following KCS for further troubleshooting:${RESET}${RED} https://access.redhat.com/articles/5900841#operator${RESET}"
      else
          echo -e "${YELLOW}Searching for KCS Solutions...${RESET}"
          api_url="https://api.access.redhat.com/support/search/kcs?fq=documentKind:(%22Solution%22)&q=*$search_string*&rows=3&start=0"

  	    # Make the API call and store the response in a variable
          api_response=$(curl -s -X GET -u "$username:$pass" "$api_url")

          # Check if the API call was successful (HTTP status code 200)
          http_status_code=$(curl -s -o /dev/null -w "%{http_code}" "$api_url")

          if [ "$http_status_code" -eq 200 ]; then
              echo "API call was successful."
              echo "API Response:"
              echo "$api_response" | grep -o 'https://access.redhat.com/solutions/[^ ]*' | sed -e 's/["}].*//'
          else
              echo "API call failed with HTTP status code $http_status_code."
          fi
      fi
  }

  # Function to gather OAuth server logs
  get_oauth_server_logs() {
      echo -e "${YELLOW}Checking OAuth Pod Status...${RESET}"
      echo

      echo -e "${GREEN}oc get pods -n openshift-authentication${RESET}"
      oc get pods -n openshift-authentication
      echo
      echo -e "${YELLOW}Gathering OAuth Server Logs...${RESET}"
      oauth_pod=$(oc get pods -n openshift-authentication -o=jsonpath='{.items[?(@.metadata.labels.app=="oauth-openshift")].metadata.name}')

      if [ -n "$oauth_pod" ]; then
          pod1=$(oc get pod -n openshift-authentication | awk 'NR==2{print $1}')
          echo
          echo -e "${GREEN}Capturing logs from pod/$pod1${RESET}"
          oc --tail 100 logs $pod1 -n openshift-authentication | grep -E 'error|failed|degraded|timeout|expire|canceled'

          pod2=$(oc get pod -n openshift-authentication | awk 'NR==3{print $1}')
          echo
          echo -e "${GREEN}Capturing logs from pod/$pod2${RESET}"
          oc --tail 100 logs $pod2 -n openshift-authentication | grep -E 'error|failed|degraded|timeout|expire|canceled'

          pod3=$(oc get pod -n openshift-authentication | awk 'NR==4{print $1}')
          echo
          echo -e "${GREEN}Capturing logs from pod/$pod3${RESET}"
          oc --tail 100 logs $pod3 -n openshift-authentication | grep -E 'error|failed|degraded|timeout|expire|canceled'
          echo
      else
          echo "No OAuth Server pod found."
      fi
  }

  get_users_and_identities() {
      # Check user and identity count
      echo -e "${YELLOW}Checking user and identity count for any discrepency. The user count is always greater than the identity count due to backplane user. If this difference is more than 1, it is considered an a discrepency.${RESET}"
      user_count=$(oc get users | grep -v NAME | wc -l)
      echo -e "${GREEN}USERS COUNT${RESET} = $user_count"

      identity_count=$(oc get identity | grep -v NAME | wc -l)
      echo -e "${GREEN}IDENTITY COUNT${RESET} = $identity_count"

      difference=$(echo "scale=2; $user_count - $identity_count" | bc)

      # Check if the difference is greater than 1
      if (( $(echo "$difference > 1" | bc -l) )); then
          echo -e "${YELLOW}There appears to be a discrepency in the user and identity count. Please review the below listed user and identity to find out the discrepency.${RESET}"
          echo -e "${YELLOW}Listing Users...${RESET}"
          oc get users
          echo
  	#print_horizontal_line "-" 120
          echo -e "${YELLOW}Listing identities...${RESET}"
          oc get identity
          echo
      else
          echo -e "${GREEN}As per the analysis, there is no discrepency in the user/identity count.${RESET}"
      fi
  }

  gather_route_data(){
      echo
      echo -e "${YELLOW}Gathering data for route...${RESET}"
      echo
      echo -e "${GREEN}oc get route -n openshift-authentication${RESET}"
      oc get route -n openshift-authentication
      echo
  }

  get_prometheus_graph_links() {
      echo
      echo -e "${YELLOW}Running prometheus queries...${RESET}"
      echo -e "${YELLOW}Please navigate to the following links to review metrics related to the authentication operator:${RESET}"
      echo

      command_to_run="ocm backplane console $cluster_id"

      # Define the file to store the command output
      output_file="console_url_file.txt"

      # Step 1: Open a new terminal, run the command, and store its output
      gnome-terminal -- bash -c "$command_to_run > $output_file; read -n 1 -p 'Press any key to exit.'; exit"

      sleep 60

      console_url=$(grep -o 'http[^\ ]*' $output_file)

      echo -e "${GREEN}1. MONITORING DASHBOARD for namespace/openshift-authentication: ${RESET}"
      query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=openshift-authentication&type=deployment"
      echo
      query_url="$console_url/$query"
      echo -e "$query_url"
      echo

      echo -e "${GREEN}2. MONITORING DASHBOARD for namespace/openshift-authentication-operator: ${RESET}"
      query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=openshift-authentication-operator&type=deployment"
      echo
      query_url="$console_url/$query"
      echo -e "$query_url"
      echo

      echo -e "${GREEN}3. Query Executed:${RESET} ${YELLOW}up{service="metrics", namespace="openshift-authentication-operator"}${RESET}"
      echo -e "This query provides information about the ${GREEN}up${RESET} status of service inside the namespace/openshift-authentication-operator"
      query="up%7Bservice%3D%22metrics%22%2C+namespace%3D%22openshift-authentication-operator%22%7D"
      query_url="$console_url/monitoring/query-browser?query0=$query"
      echo -e "$query_url"
      echo

      echo -e "${GREEN}4. Query Executed:${RESET} ${YELLOW}sum(rate(kube_pod_container_status_restarts_total{pod=~"authentication-operator.*"}[5m]))${RESET}"
      echo -e "This Prometheus query calculates the sum of the per-second rates of pod restarts for ${GREEN}authentication-operator pod${RESET} over the last 5 minutes. It gives you an indication of how frequently containers within authentication operator pods are restarting,"
      query="sum%28rate%28kube_pod_container_status_restarts_total%7Bpod%3D~"authentication-operator.*"%7D%5B5m%5D%29%29"
      query_url="$console_url/monitoring/query-browser?query0=$query"
      echo -e "$query_url"
      echo

      echo -e "${GREEN}5. Query Executed:${RESET} ${YELLOW}sum(rate(kube_pod_container_status_restarts_total{pod=~"oauth-openshift.*"}[5m]))${RESET}"
      echo -e "This Prometheus query calculates the sum of the per-second rates of pod restarts for ${GREEN}oauth pods${RESET} over the last 5 minutes. It gives you an indication of how frequently containers within authentication operator pods are restarting,"
      query="sum%28rate%28kube_pod_container_status_restarts_total%7Bpod%3D~"oauth-openshift.*"%7D%5B5m%5D%29%29"
      query_url="$console_url/monitoring/query-browser?query0=$query"
      echo -e "$query_url"
      echo

      echo -e "${RED}To get in touch with OCP engineering for this operator, join #forum-apiserver slack channel and ping @api-auth-apiserver-component-questions handle with queries.${RESET}"
  }

  # Main function
  main() {
      login_via_backplane
      get_basic_info
      check_authentication_operator
      check_operator_resources
      get_authentication_operator_logs
      get_oauth_server_logs
      get_users_and_identities
      gather_route_data
      build_search_string
      search_kcs
      get_prometheus_graph_links
  }

  main
}

# :command.function
inceptor_check_cloud_credential_command() {
  # src/check_cloud_credential_command.sh
  #!/usr/bin/env bash

  BDEF='\x1B[1m'
  BRED='\x1B[1;31m'
  RED='\x1B[0;31m'
  BYEL='\x1B[1;33m'
  YEL='\x1B[0;33m'
  BGRN='\x1B[1;32m'
  GRN='\x1B[0;32m'
  NC='\x1B[0m' # RESET
  cluster_id="${args[clusterid]}"

  # For KCS search string -------
  declare -A search_strings

  # Title, separator, logs format -------
  inc_title() {
    echo -e "${YEL}$*${NC}\n"
  }

  inc_separator() {
      echo -e "\n${GRN}------------------------------------------------------------------------${NC}"
  }

  format_logs() {
    while IFS= read -r line; do
      echo $line | sed -e "s/info/${BDEF}&${NC}/" -e "s/\(error\|timeout\|unavailable\)/${BRED}&${NC}/" -e "s/warning/${BYEL}&${NC}/"
    done <<< "$1"
  }

  # Cluster login via ocm backplane -------
  inc_login() {
    echo -e "\n${YEL}Logging into cluster via backplane...${NC}\n"
    ocm_outuput=$(ocm backplane login $cluster_id)
    whoami_output=$(oc whoami 2>&1)
    if [[ $whoami_output == *"rror"* ]]; then
      echo -e "\n${RED}Couldn't login to cluster ${cluster_id}\nexiting..${NC}"
      exit 1
    else
      echo -e "\n${GRN}Login successful. ${NC}"
    fi
  }

  print_json() {
    OUTPUT_FORMAT="${OUTPUT_FORMAT:-yaml}"

    if [[ $OUTPUT_FORMAT == "yaml" ]]; then
      echo "$*" | jq '.' | sed -E -e 's/\{|\}|\[|\]|\"//g' -e 's/,\s*$//g'
    else
      echo "$*" | jq -C '.'
    fi
  }

  # For default browsers when prom links function executed -------
  os_default_browser() {
    case $(uname | tr '[:upper:]' '[:lower:]') in
    linux*)
      OPEN="xdg-open"
      ;;
    darwin*)
      OPEN="open"
      ;;
    esac
  }

  # Cluster Basic information -------
  get_basic_info() {
    inc_separator
    inc_title "Listing basic information about the cluster..."
    osdctl -S cluster context $cluster_id

    inc_separator
    inc_title "Listing the service logs sent in past 30 days..."
    osdctl -S servicelog list $cluster_id

    inc_separator
    inc_title "Checking node status..."
    oc get nodes
  }

  run_cloud_credential_operator() {
    cco_status
    cco_pods
    cco_resource
    cco_pod_logs
    search_kcs
    get_prometheus_graph_links "openshift-cloud-credential-operator"
    print_additional_info "forum-cloud-credential-operator"
  }

  cco_status() {
    inc_separator
    local cco_conditions

    inc_title "Checking status for Cloud Credential Operator..."
    oc get co cloud-credential
    cco_conditions=$(oc get co cloud-credential -o json | jq '.status | {status: {"conditions"}} | .status.conditions |= sort_by(.lastTransitionTime) | .status.conditions |= reverse')

    formatted_cco_conditions=$(print_json $cco_conditions | sed -e "s/Degraded/${BRED}&${NC}/g")
    echo -e "$formatted_cco_conditions"

    degraded_messages=$(echo "$cco_conditions" | jq '.status.conditions | .[] | select(.type == "Degraded" and .status == "True") | .message')
    progressing_messages=$(echo "$cco_conditions" | jq '.status.conditions | .[] | select(.type == "Progressing" and .status == "True") | .message')

    if [[ -n $degraded_messages ]]; then
      error_messages=$(echo -e "$degraded_messages" | head -n 1)
    elif [[ -n $progressing_messages ]];then
      error_messages=$(echo -e "$progressing_messages" | head -n 1)
    fi

    while IFS= read -r err_msg; do
      if [[ -n $err_msg ]]; then search_strings["$err_msg"]=1; fi
    done <<< "$error_messages"

  }

  cco_pods() {
    inc_separator
    inc_title "Checking pods status for Cloud Credential Operator..."
    oc -n openshift-cloud-credential-operator get pods
  }

  cco_resource() {
    inc_separator
    inc_title "Checking cloud credential resource.."
    oc get cloudcredential cluster -o yaml
  }

  cco_pod_logs() {
    inc_separator
    local pod_logs
    local logs_answer
    local full_pod_logs
    local default_logs=15

    inc_title "Gathering pod logs for Cloud Credential Operator..."
    pod_logs=$(oc -n openshift-cloud-credential-operator logs --tail=$default_logs deployment/cloud-credential-operator -c cloud-credential-operator)

    if [[ -z $pod_logs ]]; then
      echo -e "\n${YEL}No logs were found\nskipping ...${NC}"
      return 1
    fi

    local formated_pod_logs=$(format_logs "$pod_logs")
    echo -e "$formated_pod_logs"

    while true; do
    echo -e "\n"
    read -p "Do you want to open the full logs (y/n)? " logs_answer
      case $logs_answer in
        [yY])
          echo -e "${GRN}Collecting the full logs ..${NC}"

          # For full logs (1000 logs) -------
          full_pod_logs=$(oc -n openshift-cloud-credential-operator logs --tail=1000 deployment/cloud-credential-operator -c cloud-credential-operator 2>&1)
          local formatted_full_pod_logs=$(format_logs "$full_pod_logs")
          echo -e "$formatted_full_pod_logs" | less -r
          break
        ;;
        [nN])
          break
        ;;
        *)
          echo -e "${YEL}Invalid input. Please answer (y)es or (n)o${NC}"
        ;;
      esac
    done

  # Search KCS -------
  search_kcs() {
    local search_header="openshift-cloud-credential-operator"
    local search_params='documentKind:("Solution")'
    local api_url_pattern="https://api.access.redhat.com/support/search/kcs?fq=P_DATA&q=Q_DATA&rows=3&start=0"

    inc_separator
    if [[ ${#search_strings[@]} -eq 0 ]]; then

      echo -e "${GRN}Couldn't build a valid search string. It looks like the operator is not being reported as degraded. If there are issues with the operator, please review the logs and resources related to cloud-credential pods${NC}"
      return 1
    fi
    echo -e "${YEL}Searching for KCS Solutions...${NC}"
    for issue in "${!search_strings[@]}"; do
      issue="${issue##*:}"
      compiled_search="$search_header $issue"
      compiled_search_encoded=$(jq -rn --arg x "$compiled_search" '$x|@uri')
      search_params_encoded=$(jq -rn --arg x "$search_params" '$x|@uri')

      api_url="$api_url_pattern"
      api_url=${api_url//P_DATA/$search_params_encoded}
      api_url=${api_url//Q_DATA/$compiled_search_encoded}

      echo -e "\nDetected issue: ${YEL}$issue${NC}"
      echo -e "Suggested KCS solution(s):"

      kcs_solutions=$(curl -s -u "$username:$password" "$api_url" | jq -r '.response.docs | .[] | .view_uri')
      echo -e "${GRN}${kcs_solutions:-Nothing was found}${NC}"
      echo -e ""
    done
  }

   # For KCS search strs of logs --------
    logs_search_patterns=("CredentialsProvisionFailure" "InsufficientCloudCreds" "ebs-cloud-credentials not found" "disabled" "empty awsSTSIAMRoleARN" "InvalidClientTokenId" "unable to read info for username")
    for search_str in "${logs_search_patterns[@]}"; do
      err_logs=$(grep --color=never -F "${search_str}" <<< ${full_pod_logs:-$pod_logs})
      if [[ -z $err_logs ]]; then continue; fi

      while IFS= read -r line; do
        err_msg=$(echo $line | grep -m 1 -o 'msg="[^"]*"')
        err_msg=${err_msg#msg=\"} ; err_msg=${err_msg%\"}
        search_strings["$err_msg"]=1
      done <<< "$err_logs"
    done
  }

   # Prometheus link(s) -------

   # NOTE: For supported operators
  get_prometheus_graph_links() {
    local prom_namespace
    local promql_rules_param
    local rules_url

    # Timeout period for console URL (in seconds) -------
    local timeout=240

    console_output_file="TEMP_CONSOLE.txt"

    inc_separator
    prom_namespace=$1
    inc_title "prometheus metrics related to $prom_namespace"

    # For prom alert rules -------
    case $prom_namespace in
      openshift-cloud-credential-operator)
      promql_rules_param='cco_credentials_requests_conditions{condition=~"CredentialsDeprovisionFailure|CloudCredentialOperatorDeprovisioningFailed|CloudCredentialOperatorInsufficientCloudCreds|CloudCredentialOperatorProvisioningFailed|CloudCredentialOperatorStaleCredentials|CloudCredentialOperatorTargetNamespaceMissing"}'
      ;;
    esac

    echo -e "${GRN}Collecting console url...${NC}"

    # For backplane console runs in the same terminal -------
    if [[ -z ${console_url} ]]; then
      podman machine init &> /dev/null
      sleep 1
      podman machine start &> /dev/null
      podman container rm --all --force -i --depend &> /dev/null

      pkill -9 -f "backplane console"
      sleep 15
      rm $console_output_file &> /dev/null

      touch $console_output_file

    # Capturing Console URL -------
      ocm backplane console >> $console_output_file 2>&1  &

      local skipped=true
      for i in $(seq 1 $timeout); do
        if grep -q -e "http" -e "rror" $console_output_file; then
          console_url=$( cat $console_output_file | awk '/available at/ {print $6}')
          skipped=false
          break
        fi
        sleep 1
      done
    fi

   # Console URL fetched -------
    if echo "$console_url" | grep -q "http"; then
      echo -e "Success: ${GRN}$console_url${NC}\n"

    elif [[ $skipped == true ]]; then
      echo -e "${YEL}TIMEOUT ERROR: Unable to retrieve the Console URL.${NC}"
      echo -e "skipping prometheus..."
      console_url=""
      return 1

    else
      local console_error=$(<$console_output_file)
      echo -e "${YEL}The following error occurs while trying to get console URL:\n${RED}--\n$console_error\n--${NC}"
      echo -e "skipping prometheus..."
      console_url=""
      return 1
    fi

   # Dashboard --------
    echo -e "${GRN}1. MONITORING DASHBOARD${NC}"
    dashboard_query="monitoring/dashboards/grafana-dashboard-k8s-resources-workloads-namespace?namespace=$prom_namespace&type=deployment"
    dashboard_url="$console_url/$dashboard_query"
    echo -e "$dashboard_url"

    # Failed jobs --------
    echo -e "\n"
    echo -e "${GRN}2. FAILED jobs inside the namespace/$prom_namespace${NC}"
    promql_param='kube_job_status_failed{namespace="USED_NAMESPACE"}'
    promql_param_encoded=$(jq -rn --arg x ${promql_param//USED_NAMESPACE/$prom_namespace} '$x|@uri')
    failed_jobs_query="monitoring/query-browser?query0=$promql_param_encoded"
    failed_jobs_url="$console_url/$failed_jobs_query"
    echo -e "$failed_jobs_url"

    # Prometheus alert rules -------

    # NOTE: For supported operators
    if [[ -n "$promql_rules_param" ]]; then
        echo -e "\n"
        echo -e "${GRN}3. FIRED ALERT rules for namespace/$prom_namespace${NC}"
        promql_rules_param_encoded=$(jq -rn --arg x ${promql_rules_param} '$x|@uri')
        rules_query="monitoring/query-browser?query0=$promql_rules_param_encoded"
        alert_rules_url="$console_url/$rules_query"
        echo -e "$alert_rules_url"
    fi

    echo -e "\n"
    echo -e "${GRN}Opening the URLs in the browser ..${NC}"
    $OPEN "$dashboard_url" &>/dev/null
    $OPEN "$failed_jobs_url" &>/dev/null
    if [[ -n "$promql_rules_param" ]]; then
      $OPEN "$alert_rules_url" &>/dev/null
    fi
  }

  # Additional Information -------
  print_additional_info() {
    inc_separator
    inc_title "Additional Information :"
    echo -e "To get in touch with OCP engineering for this operator, join ${GRN}$1${NC} slack channel for any inquiries."
  }

  main() {
    if [[ -z $cluster_id ]]; then echo -e "${YEL}missing cluster ID${NC}"; exit 1; fi
    os_default_browser
    inc_login
    get_basic_info
    run_cloud_credential_operator
  }

  main
}

# :command.function
inceptor_check_cluster_health_command() {
  # src/check_cluster_health_command.sh
  #!/bin/bash

  cluster_id="${args[clusterid]}"

  ocm backplane login $cluster_id

  jobDetails=$(ocm backplane managedjob create CEE/cluster-health-check)

  while read -r line; do
      # Check if the line contains "ocm backplane managedjob get"
      if [[ $line == *"ocm backplane managedjob get openshift-job-"* ]]; then
          # If found, store it in check_job_status variable
          check_job_status="$line"
          break  # Exit loop after finding the first occurrence
      fi
  done <<< "$jobDetails"

  while read -r line; do
      # Check if the line contains "ocm backplane managedjob get"
      if [[ $line == *"ocm backplane managedjob logs openshift-job-"* ]]; then
          # If found, store it in check_job_status variable
          get_logs="$line"
          break  # Exit loop after finding the first occurrence
      fi
  done <<< "$jobDetails"

  check_status() {
      # Run the command and store the output in a variable
      jobGetOutput=$(eval "$check_job_status")

      # Extract the STATUS field using awk
      status=$(echo "$jobGetOutput" | awk 'NR==2{print $2}')

      # Return the status
      echo "$status"
  }

  # Loop until status is "Succeeded"
  while true; do
      # Check the status
      status=$(check_status)

      # Check if status is "Succeeded"
      if [ "$status" = "Succeeded" ]; then
          echo "Job Status is Succeeded. Checking job logs..."
          eval "$get_logs"
          break  # Exit the loop
      else
          echo "Waiting for status to be Succeeded..."
          sleep 15  # Wait for some time before checking again
      fi
  done
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        inceptor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    check | c)
      action="check"
      shift
      inceptor_check_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      inceptor_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
inceptor_check_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    image-registry | ir)
      action="image-registry"
      shift
      inceptor_check_image_registry_parse_requirements "$@"
      shift $#
      ;;

    authentication | auth)
      action="authentication"
      shift
      inceptor_check_authentication_parse_requirements "$@"
      shift $#
      ;;

    cloud-credential | cc)
      action="cloud-credential"
      shift
      inceptor_check_cloud_credential_parse_requirements "$@"
      shift $#
      ;;

    cluster-health | ch)
      action="cluster-health"
      shift
      inceptor_check_cluster_health_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      inceptor_check_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
inceptor_check_image_registry_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_image_registry_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check image-registry"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check image-registry CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_authentication_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_authentication_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check authentication"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check authentication CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_cloud_credential_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_cloud_credential_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check cloud-credential"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check cloud-credential CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
inceptor_check_cluster_health_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        inceptor_check_cluster_health_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check cluster-health"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['clusterid']+x} ]]; then
          args['clusterid']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['clusterid']+x} ]]; then
    printf "missing required argument: CLUSTERID\nusage: inceptor check cluster-health CLUSTERID\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "check") inceptor_check_command ;;
    "check image-registry") inceptor_check_image_registry_command ;;
    "check authentication") inceptor_check_authentication_command ;;
    "check cloud-credential") inceptor_check_cloud_credential_command ;;
    "check cluster-health") inceptor_check_cluster_health_command ;;
  esac
}

initialize
run "$@"
